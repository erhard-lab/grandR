---
title: "single-cell"
output: 
  html_document:
    toc: true
    df_print: kable
    fig_width: 7
    fig_height: 6
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,comment=NA,R.options=list(width = 95))
```

## Loading single-cell data

Single-cell data in the form of feature-barcode matrices can be directly read into a grandR object. Two matrices must be prepared, one containing total counts, one containing new RNA counts. To demonstrate this, we will use publicly available data on cortisol response in single-cells of the A549 cell-line, including matrices of total and newly synthesized RNA (https://www.nature.com/articles/s41587-020-0480-9). The data is available on GEO under the accession ID GSM3770930. 

First load the necessary packages.
```{r}
suppressPackageStartupMessages({
    library(grandR)
    library(ggplot2)
    library(patchwork)
    library(Seurat)
})

```

Since we are downloading large files, the download may take some time.
The default time limit in R is 60 seconds, which might be insufficient.
We change increase the time limit as follows:

```{r}
options(timeout=600)
getOption("timeout")
```

Then we download the data and load them into grandR. The files assigned to the `genes`,`cells` and `total.matrix` is the normal matrix-market format that are generated by most single cell processing pipelines (such as CellRanger or STARsolo). Equivalently, `genes`,`cells` and`new.matrix` is a matrix-marked formatted matrix containing counts of read with T-to-C mismatches.

Importantly, GRAND-SLAM output of single cell data can be read as usual using the `ReadGRAND` function. The `detection.rate` defines how many reads that truly originate from labeled RNA have been recognized as such by having a T-to-C mismatch. For details, see the [sci-fate paper](https://www.nature.com/articles/s41587-020-0480-9). 82% is the value that has been estimated in this paper.

```{r}
d <- ReadNewTotal(genes = "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSM3770930&format=file&file=GSM3770930%5FA549%5Fgene%5Fannotate%2Etxt%2Egz",
                  cells = "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSM3770930&format=file&file=GSM3770930%5FA549%5Fcell%5Fannotate%2Etxt%2Egz",
                  new.matrix = "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSM3770930&format=file&file=GSM3770930%5FA549%5Fgene%5Fcount%5Fnewly%5Fsynthesised%2Etxt%2Egz",
                  total.matrix = "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSM3770930&format=file&file=GSM3770930%5FA549%5Fgene%5Fcount%2Etxt%2Egz",
                  verbose=TRUE,
                  detection.rate = 0.82)
```
Now, `d` is a grandR object containing single cell data:
```{r}
d
```

Note that also the cell meta-data has been loaded correctly, which is the `Coldata` in grandR terms:

```{r}
head(Coldata(d))
```


## Pre-processing the data

We now could directly hand-over data to Seurat. However, pre-processing and analyses can also be performed in grandR. We filter genes such that only genes remain that have at least one UMI in at least 100 cells.

```{r}
d <- FilterGenes(d, mode.slot = "count", minval = 1, mincol = 100)
d
```


## Computing new RNA percentage

We can also obtain some statistics, e.g. on the percentage of new RNA per cell, and the percentage of mitochondrial gene expression.

```{r}
d <- ComputeExpressionPercentage(d,"percent.new",
                                 mode.slot="new.count",mode.slot.total="count")
d <- ComputeExpressionPercentage(d,"percent.mt",
                                 genes=Genes(d,"^MT-",regex=TRUE))  
# results in 0 for all genes, have been filtered on GEO!
```

The computed percentages are now part of the coldata:

```{r}
head(Coldata(d))
```

Here, the global percentage of new RNA correlates very well with the percentage of intronic reads in each cell (which is part of the table downloaded from GEO), i.e. there are two independent pieces of evidence that there are cells that are transcriptionally more active than others:

```{r fig.alt = "Scatter plot comparing % new vs intronic reads"}
PlotScatter(Coldata(d),percent.new,all_intron/all_reads*100,
            correlation = FormatCorrelation(),
            remove.outlier = FALSE)
```
``

## Seurat

Data can be handed over to Seurat. For that, *modalities* and a *mode* must be defined. Allowed modalities are 
  * total (total counts)
  * new (new counts)
  * old (old counts)
  * prev (estimated counts from the onset of labeling extrapolated using gene specific RNA half-lives)

The mode is one of four options (as outlined in this [review](https://www.nature.com/articles/s43586-022-00171-1)):
  * assay: for each modality, the Seurat object will contain an assay
  * cells: cells are copied for each modality
  * genes: genes are copied for each modality
  * list: a list of Seurat objects is returned
  

```{r}
s <- as.Seurat(d, modalities=c(RNA='total',newRNA="new"), mode="assay")
s
```

The percentage of new RNA could now be used as an additional QC filter:

```{r fig.alt = "Violin plots showing % new per cell"}
VlnPlot(s,features = "percent.new",group.by = "treatment_time")
```

E.g. cells with extremely high amounts of new or old RNA could be filtered out. This step should only be done with care. Here we skip it, since the correlation with the percentage of intronic reads provides independent evidence that the high variance in new RNA content is biological.

Note that the new Seurat object has two assays, RNA and newRNA (which are the names we defined for the modalities). Let's do the normal Seurat workflow for total RNA:

```{r message=FALSE, warning=FALSE, fig.alt = "UMAP colored according to time point"}
s <- NormalizeData(s)
s <- FindVariableFeatures(s)
s <- ScaleData(s)
s <- RunPCA(s,verbose = FALSE)
s <- RunUMAP(s,dims=1:10)
DimPlot(s,group.by = 'treatment_time') 
# treatment_time was transferred from the grandR Coldata table!
```

And now repeat with new RNA:

```{r message=FALSE, warning=FALSE, fig.alt = "UMAP by new RNA colored according to time point"}
DefaultAssay(s) <- 'newRNA'
s <- NormalizeData(s)
s <- FindVariableFeatures(s)
s <- ScaleData(s)
s <- RunPCA(s,verbose = FALSE)
s <- RunUMAP(s,dims=1:10)
DimPlot(s,group.by = 'treatment_time')
```


