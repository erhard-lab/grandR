---
title: "Estimation of synthesis and degradation rates from snapshot experiments"
author: "Lygeri Sakellaridi"
date: "6/30/2022"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Kinetic modeling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Synthesis and degradation can be estimated from a single time point in an 
unbiased way and without assuming steady state. In this vignette we explore how.

Throughout the vignette, "sigma" and "delta" are used as short terms for
"synthesis rate" and "degradation rate" respectively.

# Data simulation

We simulate a data set based on the SARS-CoV-2 data set from Finkel et al. 2021
[[3]](https://www.nature.com/articles/s41586-021-03610-3). The data set contains 
time series samples from the human epithelial cell line (Calu3 cells); half of the samples were infected with SARS-CoV-2 for different periods of time.

In the mock samples, we perturb synthesis (sigma) or degradation (delta) rate.
We also leave a simulation unperturbed as control. We simulate three replicates from the 2h time point.

```{r}
suppressPackageStartupMessages({library(grandR)})
if (!file.exists("snapshot.est.step1.rds")) {
  
 
sars <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz",
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
sars <- subset(sars,columns=Condition(sars)=="Mock")
sars <- FilterGenes(sars)
sars <- Normalize(sars)
SetParallel()
sars <- FitKinetics(sars,type="nlls")
seed = 1337
f0 <- GetAnalysisTable(sars)$kinetics.Mock.Synthesis/log(2)*GetAnalysisTable(sars)$`kinetics.Mock.Half-life`
control <- SimulateTimeCourse("control", GeneInfo(sars),
                           s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis,
                           d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life`,
                           dispersion = estimate.dispersion(GetTable(sars,type="count")),
                           f0 = f0,
                           s.variation = 1.05,
                           d.variation = 1.05,
                           timepoints = c(2, 2, 2),
                           beta.approx = TRUE, num.reads = 5E7, seed = seed)
unperturbed <- SimulateTimeCourse("unperturbed", GeneInfo(sars),
                                 s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis,
                                 d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life`,
                                 dispersion=estimate.dispersion(GetTable(sars,type="count")),
                                 f0 = f0,s.variation = 1.05,d.variation = 1.05,timepoints = c(2,2,2),
                                 beta.approx = TRUE,
                                 num.reads=5E7,
                                 seed=seed*13)
perturbed.d <- SimulateTimeCourse("HL", GeneInfo(sars),
                                 s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis,
                                 d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life` *2^rnorm(nrow(sars),0,1) ,
                                 dispersion = estimate.dispersion(GetTable(sars,type="count")),
                                 f0 = f0, s.variation = 1.05, d.variation = 1.05,
                                 timepoints = c(2,2,2),beta.approx = TRUE,
                                 num.reads=5E7, seed = seed*13*13)
perturbed.s <- SimulateTimeCourse("s", GeneInfo(sars),
                                 s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis *2^rnorm(nrow(sars),0,1) ,
                                 d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life`,
                                 dispersion = estimate.dispersion(GetTable(sars,type="count")),
                                 f0 = f0, s.variation = 1.05, d.variation = 1.05,
                                 timepoints = c(2,2,2),
                                 beta.approx = TRUE, num.reads = 5E7,
                                 seed=seed*13*13*13)

saveRDS(control, "reg.control.rds")
saveRDS(unperturbed, "reg.unperturbed.rds")
saveRDS(perturbed.s, "reg.perturbed.s.rds")
saveRDS(perturbed.d, "reg.perturbed.d.rds")

m <- merge(control = control, unperturbed = unperturbed, perturbed.d = perturbed.d, perturbed.s = perturbed.s)
# In GeneInfo, they will be called true_d.name, true_s.name
saveRDS(m, "regulation.step1.rds")
} else {
  m <- readRDS("regulation.step1.rds")
} 

```

All simulations used in these vignette, as well as equivalent simulations for 
the 1h and 4h time points, are available here (insert Internet location).

# Testing causes of log-fold change (LFC) between conditions in old and new RNA

To estimate sigma and delta, we can use the following equations:

(3)

(4)

Two theoretical considerations stem from these equations: 

1. A LFC in the old RNA between conditions means that either the
RNA labels before labeling were already different, or that delta differs by
an additive constant rather than a multiplicative factor.

To test this, we compare the LFC between the control and the simulation with 
pertubed delta:

```{r}
# Plot to svg in general, unless it's too many points 
# then, png (scatter plots)
# inkscape to put them together (for svg)

# Get LFC values for old RNA
m <- LFC(m, "old", GetContrasts(m, contrast = c("Condition","control")), mode="old")

# Get analysis table
anal.table <- GetAnalysisTable(m)

a <- GeneInfo(m)$true_d
b <- GeneInfo(m)$true_d.perturbed.d
lfc.perturbed.d.vs.control.old <- log2(a/b)
lfc.unperturbed.vs.control.old <- anal.table$`old.HL vs control.LFC`

# Put LFC of unperturbed vs perturbed delta in a dataframe
df.old <- data.frame(cbind(lfc.perturbed.d.vs.control.old, lfc.unperturbed.vs.control.old))

# Use PlotScatter
# Fig4A
# perturbed delta vs control in the title
# square, smaller, same range in both axes, add main diagonal
PlotScatter(df.old, remove.outlier = 999) + xlab("log FC half-life (truth)") + ylab("log FC old RNA") + ggtitle("Perturbed degradation rate vs control") + geom_abline()
```

We can see there is no linear correlation, which is expected 
from old RNA LFC resulting from an additive change in delta.

2. A LFC in new RNA, previously associated with changes in sigma, can also be
due to changes in delta. This is especially true for genes with short-lived
RNA.

To test this, we plotted delta-induced LFC for new RNA, with an emphasis
on short-lived genes. For this example, we consider "short-lived" to mean
"with a half-life <= 1 h", but we encourage users to experiment with different
cutoffs.

First, we will make a list that contains all the names of short-lived genes.
In order to do this, we will extract the true values for delta from the analysis
table of our grandR object and then convert them to half-lives using the 
following equation from [REF: grand-slam paper]:

(9)

```{r}
m <- LFC(m, "new", GetContrasts(m, contrast = c("Condition","control")), mode = "new")
anal.table <- GetAnalysisTable(m)
threshold <- 1 # our half-life threshold for short-lived genes
hl <- log(2)/anal.table$true_d
genes <- rownames(anal.table)
short.lived.genes <- genes[hl <= threshold]
```

Now we can make our scatter plot:

```{r}
lfc.perturbed.d.vs.control.new <- log2(GeneInfo(m)$true_d/GeneInfo(m)$true_d.perturbed.d)
lfc.unperturbed.vs.control.new <- anal.table$`new.HL vs control.LFC`

df.new <- data.frame(cbind(lfc.perturbed.d.vs.control.new, 
                           lfc.unperturbed.vs.control.new))
rownames(df.new) <- rownames(anal.table) # add gene names to data frame

# PlotScatter, new RNA unpertubed vs pertubed delta LFC
# Fig4B
# Change highlight color so it's not red and green?
PlotScatter(df.new, highlight = short.lived.genes, remove.outlier = 999) + xlab("log FC degradation rate (truth)") + ylab("log FC new RNA") + ggtitle("Perturbed degradation rate vs control")
```

We can see there are significant LFCs for short-lived genes when delta
(but not sigma) is changed. 

# Unbiased estimation of synthesis and degradation rates

We have seen that it is possible to estimate sigma and delta from equations
(3) and (4). However, these estimates can be inaccurate due to technical
factors (eg low number of reads) as well as subject to biological variability
between replicates.

To estimate sigma and delta without the bias introduced by these factors, we 
apply a Bayesian hierarchical model:

```{r}
# Add total RNA
m <- LFC(m,"total", GetContrasts(m, contrast = c("Condition","control")), mode="total")

# EstimateRegulation
m <- Normalize(m)

SetParallel()
m <- EstimateRegulation(m, "Regulation", contrasts = GetContrasts(m, contrast = c("Condition","control")), reference.columns = FindReferences(m, Condition == "control", group = NULL),verbose = TRUE, sample.f0.in.ss = TRUE)

saveRDS(m, "regulation.step2.rds")

# Get new analysis table 
anal.table <- GetAnalysisTable(m)

# PlotScatter on estimates vs true sigma/delta; slope should be 1, meaning no bias

true.s.lfc <- log2(GeneInfo(m)$true_s.perturbed.s/GeneInfo(m)$true_s)
est.s.lfc <- anal.table$`Regulation.s vs control.s.log2FC`

true.hl.lfc <- -log2(GeneInfo(m)$true_d.perturbed.d/GeneInfo(m)$true_d)
est.hl.lfc <- anal.table$`Regulation.HL vs control.HL.log2FC`

df.hl <- data.frame(cbind(true.hl.lfc, est.hl.lfc))
df.s <- data.frame(cbind(true.s.lfc, est.s.lfc))
```

Plotting the estimates of sigma and delta against their true values results 
in a scatterplot with a slope close to 1, indicating that the estimates are 
unbiased:

```{r}
# Fig4C
PlotScatter(df.hl, remove.outlier = 999) + geom_abline() + xlab("log FC half-life (truth)") + ylab("log FC half-life (MAP estimate)")
 + ggtitle("Perturbed degradation rate vs control")
```

```{r}
# Fig4D
PlotScatter(df.s, remove.outlier = 999) + geom_abline() + xlab("log FC synthesis rate (truth)") + ylab("log FC synthesis rate (MAP estimate)") + ggtitle("Perturbed synthesis rate vs control")
```

We also observe that sigma and delta are small for the unperturbed simulations, and that the variance for delta is substantially larger than the variance for sigma:

```{r}
library(ggplot2)
library(reshape2)
box.hl <- data.frame(unperturbed.vs.control = anal.table$`Regulation.unperturbed vs control.HL.log2FC`,
                     hl.vs.control = anal.table$`Regulation.HL vs control.HL.log2FC`,
                     s.vs.control = anal.table$`Regulation.s vs control.HL.log2FC`)

box.hl.molten <- melt(box.hl)

# Fig4E (distribution of changes in delta)
# rotate x labels 90 degrees
# make square (aspect ratio equals 1)
ggplot(box.hl.molten, aes(x = variable, y = value)) + xlab("simulation") + ylab("log FC half-life (MAP estimate)") + geom_boxplot() + scale_x_discrete(labels = c("unperturbed vs control", "perturbed degradation rate vs control", "perturbed synthesis rate vs control")) + theme(axis.text.x = element_text(angle = 90, vjust = 1, hjust = 1), aspect.ratio = 1)

# Okay but this looks silly
```
```{r}
# Here's an attempt with angle of 20 degrees and no squaring:
ggplot(box.hl.molten, aes(x = variable, y = value)) + xlab("simulation") + ylab("log FC half-life (MAP estimate)") + geom_boxplot() + scale_x_discrete(labels = c("unperturbed vs control", "perturbed degradation rate vs control", "perturbed synthesis rate vs control")) + theme(axis.text.x = element_text(angle = 20, vjust = 1, hjust = 1))
```

Sigma: 

```{r}
box.s <- data.frame(unperturbed.vs.control = anal.table$`Regulation.unperturbed vs control.s.log2FC`,
                     hl.vs.control = anal.table$`Regulation.HL vs control.s.log2FC`,
                     s.vs.control = anal.table$`Regulation.s vs control.s.log2FC`) 

box.s.molten <- melt(box.s)

# Fig4E (sigma)
ggplot(box.s.molten, aes(x = variable, y = value)) + xlab("simulation") + ylab("log FC sigma") + geom_boxplot() + scale_x_discrete(labels = c("unperturbed vs control", "perturbed degradation rate vs control", "perturbed synthesis rate vs control")) + theme(axis.text.x = element_text(angle = 20, vjust = 1, hjust = 1))
```

# Short- and long-lived genes

It is also of interest to explore how the plots change if we keep only
short-lived or only long-lived genes. To test this, we will first get 
the gene names and half-lives from the analysis table and store the 
result into a new dataframe:

```{r}
anal.small <- data.frame(log(2)/anal.table$true_d)
rownames(anal.small) <- rownames(anal.table)
colnames(anal.small) <- "gene.halflife"
```

Then we will order the new dataframe based on (ascending) half-life:

```{r}
anal.small.ordered <- anal.small[order(anal.small$gene.halflife), , drop = FALSE]
```

To reconstruct the plots, we will consider the top and bottom 10% of genes in terms of half-life. This amounts to approximately 1084 from each side of
the dataframe:

```{r}
nrow(anal.small.ordered) # 10835 genes; 10% is 1083.5, roughly 1084
top10percent.halflife.genes <- rownames(tail(anal.small.ordered, 1084))
bottom10percent.halflife.genes <- rownames(head(anal.small.ordered, 1084))
```

We will make subsets of the GeneInfo table and the analysis table of our simulated object based on these gene sets:

```{r}
gene.info <- GeneInfo(m)
rownames(gene.info) <- gene.info$Symbol

top10percent.hl.geneinfo <- subset(gene.info, rownames(gene.info) %in% top10percent.halflife.genes)

bottom10percent.hl.geneinfo <- subset(gene.info, rownames(gene.info) %in% bottom10percent.halflife.genes)

top10percent.hl.analtable <- subset(anal.table, rownames(anal.table) %in%
                                      top10percent.halflife.genes)
bottom10percent.hl.analtable <- subset(anal.table, rownames(anal.table) %in%
                                      bottom10percent.halflife.genes)

# Sanity checks
all(rownames(top10percent.hl.geneinfo) == rownames(top10percent.hl.analtable))
all(rownames(bottom10percent.hl.geneinfo) == rownames(bottom10percent.hl.analtable))
nrow(top10percent.hl.analtable)
nrow(top10percent.hl.geneinfo)
```
Finally, we can redo the plots.

Dataframe-making code for scatterplots:

```{r}
# PlotScatter on estimates vs true sigma/delta

# top 10%
true.s.lfc.top10percent.hl <- top10percent.hl.geneinfo$true_s.perturbed.s/top10percent.hl.geneinfo$true_s 

est.s.lfc.top10percent.hl <- top10percent.hl.analtable$`Regulation.s vs control.s.log2FC`

true.hl.lfc.top10percent.hl <- -log2(top10percent.hl.geneinfo$true_d.perturbed.d/top10percent.hl.geneinfo$true_d) 
est.hl.lfc.top10percent.hl <- top10percent.hl.analtable$`Regulation.HL vs control.HL.log2FC`

df.hl.top10percent.hl <- data.frame(cbind(true.hl.lfc.top10percent.hl, est.hl.lfc.top10percent.hl))
df.s.top10percent.hl <- data.frame(cbind(true.s.lfc.top10percent.hl, est.s.lfc.top10percent.hl))

# bottom 10%
true.s.lfc.bottom10percent.hl <- bottom10percent.hl.geneinfo$true_s.perturbed.s/bottom10percent.hl.geneinfo$true_s 

est.s.lfc.bottom10percent.hl <- bottom10percent.hl.analtable$`Regulation.s vs control.s.log2FC`

true.hl.lfc.bottom10percent.hl <- -log2(bottom10percent.hl.geneinfo$true_d.perturbed.d/bottom10percent.hl.geneinfo$true_d) 
est.hl.lfc.bottom10percent.hl <- bottom10percent.hl.analtable$`Regulation.HL vs control.HL.log2FC`

df.hl.bottom10percent.hl <- data.frame(cbind(true.hl.lfc.bottom10percent.hl, est.hl.lfc.bottom10percent.hl))
df.s.bottom10percent.hl <- data.frame(cbind(true.s.lfc.bottom10percent.hl, est.s.lfc.bottom10percent.hl))
```

Then we remake the plots for half-life:

Top 10%:

```{r}
PlotScatter(df.hl.top10percent.hl)
```

Bottom 10%:

```{r}
PlotScatter(df.hl.bottom10percent.hl)
```

And synthesis rate: 

Top 10%:

```{r}
PlotScatter(df.s.top10percent.hl)
```

Bottom 10%:

```{r}
PlotScatter(df.s.bottom10percent.hl)
```

Boxplots:

Delta (top 10%):

```{r}
box.hl.top10percent.hl <- data.frame(unperturbed.vs.control = top10percent.hl.analtable$`Regulation.unperturbed vs control.HL.log2FC`,
                     hl.vs.control = top10percent.hl.analtable$`Regulation.HL vs control.HL.log2FC`,
                     s.vs.control = top10percent.hl.analtable$`Regulation.s vs control.HL.log2FC`)

box.hl.molten.top10percent.hl <- melt(box.hl.top10percent.hl)

ggplot(box.hl.molten.top10percent.hl, aes(x = variable, y = value)) +
  geom_boxplot()
```

Delta (bottom 10%):

```{r}
box.hl.bottom10percent.hl <- data.frame(unperturbed.vs.control = bottom10percent.hl.analtable$`Regulation.unperturbed vs control.HL.log2FC`,
                     hl.vs.control = bottom10percent.hl.analtable$`Regulation.HL vs control.HL.log2FC`,
                     s.vs.control = bottom10percent.hl.analtable$`Regulation.s vs control.HL.log2FC`)

box.hl.molten.bottom10percent.hl <- melt(box.hl.bottom10percent.hl)

ggplot(box.hl.molten.bottom10percent.hl, aes(x = variable, y = value)) +
  geom_boxplot()
```
Sigma (top 10%):

```{r}
box.s.top10percent.hl <- data.frame(unperturbed.vs.control = top10percent.hl.analtable$`Regulation.unperturbed vs control.s.log2FC`,
                     hl.vs.control = top10percent.hl.analtable$`Regulation.HL vs control.s.log2FC`,
                     s.vs.control = top10percent.hl.analtable$`Regulation.s vs control.s.log2FC`)

box.s.molten.top10percent.hl <- melt(box.s.top10percent.hl)

ggplot(box.s.molten.top10percent.hl, aes(x = variable, y = value)) +
  geom_boxplot()
```

Sigma (bottom 10%):

```{r}
box.s.bottom10percent.hl <- data.frame(unperturbed.vs.control = bottom10percent.hl.analtable$`Regulation.unperturbed vs control.s.log2FC`,
                     hl.vs.control = bottom10percent.hl.analtable$`Regulation.HL vs control.s.log2FC`,
                     s.vs.control = bottom10percent.hl.analtable$`Regulation.s vs control.s.log2FC`)

box.s.molten.bottom10percent.hl <- melt(box.s.bottom10percent.hl)

ggplot(box.s.molten.bottom10percent.hl, aes(x = variable, y = value)) +
  geom_boxplot()
```

# Region of practical equivalence (ROPE) analysis outperforms DESeq2

Our Bayesian model also gives us the marginal posterior distributions for
sigma and delta. It is worth noting that these distributions accurately cover
deviations from ground truth, which means that they really reflect measurement
uncertainty:

```{r}
values.s <- log2(anal.table$true_s.perturbed.s/anal.table$true_s)
values.d <- log2(anal.table$true_d/anal.table$true_d.perturbed.d)

upper.s <- anal.table$`Regulation.s vs control.s.cred.upper`
lower.s <- anal.table$`Regulation.s vs control.s.cred.lower`

upper.d <- anal.table$`Regulation.HL vs control.HL.cred.upper`
lower.d <- anal.table$`Regulation.HL vs control.HL.cred.lower`

# Count genes whose values fall within credible intervals
# Still not sure what's up with the signs...
sum(values.s < upper.s & values.s > lower.s) # 10827
sum(values.d > upper.d & values.d < lower.d) # 10815

# Most values are indeed within the boundaries
# Credible intervals are too big, more than 95% of genes fulfil the condition
# upper and lower are switched
```

This allows us to perform ROPE analysis [reference] to quantify significant
changes in sigma and delta, and compare the results to those of the frequentist approach as implemented in DESeq2.

```{r}
m <- PairwiseDESeq2(m, "new", GetContrasts(m, contrast = c("Condition","control")), mode = "new",verbose=T)
m <- PairwiseDESeq2(m, "old", GetContrasts(m, contrast = c("Condition","control")), mode="old",verbose=T)
saveRDS(m, "regulation.step3.rds")
anal.table <- GetAnalysisTable(m)
```

ROPE outperforms DEseq2 as evidenced by ROC analysis (true, kind of).

Cases: [old/new] RNA, estimate of [s/d]

Old RNA, estimate of d
```{r}
library(pROC)

# Fig4F?
# old rna, estimate of d
# keep, will be main figure
roc.rope.old.d <- roc(abs(log2(anal.table$true_d/anal.table$true_d.perturbed.d)) >= 0.25, 
               anal.table$`Regulation.HL vs control.HL.ROPE`) 
roc.deseq.old.d <- roc(abs(log2(anal.table$true_d/anal.table$true_d.perturbed.d)) >= 0.25, 
               anal.table$`old.HL vs control.P`) 
ggroc(list("ROPE" = roc.rope.old.d, "DESeq2" = roc.deseq.old.d), legacy.axes = TRUE) + ggtitle("Estimate of degradation rate - old RNA")
```

New RNA, estimate of d
```{r}
# new rna, estimate of d
# supplement
roc.rope.new.d <- roc(abs(log2(anal.table$true_d/anal.table$true_d.perturbed.d)) >= 0.25, 
               anal.table$`Regulation.HL vs control.HL.ROPE`) 
roc.deseq.new.d <- roc(abs(log2(anal.table$true_d/anal.table$true_d.perturbed.d)) >= 0.25, 
               anal.table$`new.HL vs control.P`) 
ggroc(list("ROPE" = roc.rope.new.d, "DESEq2" = roc.deseq.new.d), legacy.axes = TRUE) + ggtitle("Estimate of degradation rate - new RNA")
```

Old RNA, estimate of s
```{r}
# old rna, estimate of s
# supplement
roc.rope.old.s <- roc(abs(log2(anal.table$true_s/anal.table$true_s.perturbed.s)) >= 0.25, 
               anal.table$`Regulation.s vs control.s.ROPE`) 
roc.deseq.old.s <- roc(abs(log2(anal.table$true_s/anal.table$true_s.perturbed.s)) >= 0.25, 
               anal.table$`old.s vs control.P`) 
ggroc(list("ROPE" = roc.rope.old.s, "DESeq2" = roc.deseq.old.s), legacy.axes = TRUE) + ggtitle("Estimate of synthesis rate - old RNA")
```

New RNA, estimate of s
```{r}
# new rna, estimate of s
# keep this, will be main figure
roc.rope.new.s <- roc(abs(log2(anal.table$true_s/anal.table$true_s.perturbed.s)) >= 0.25, 
               anal.table$`Regulation.s vs control.s.ROPE`) 
roc.deseq.new.s <- roc(abs(log2(anal.table$true_s/anal.table$true_s.perturbed.s)) >= 0.25, 
               anal.table$`new.s vs control.P`) 
ggroc(list("ROPE" = roc.rope.new.s, "DESeq2" = roc.deseq.new.s), legacy.axes = TRUE) + ggtitle("Estimate of synthesis rate - new RNA")
```

# Comparison of degradation rate changes: full time course versus snapshot

We compare delta between a snapshot from a single time point (2h) versus a
full time course. We will use the real data set as the time course.

EstimateRegulation for 2h time point
Get delta from FitKinetics on full time course
then log2(Mock/SARS) (bc half-life)
```{r}
# Load sars
sars <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz",
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
sars <- FilterGenes(sars) # gene filtering before subsetting to ensure they have the same genes
# 9162 genes remain, rather than 10835 as before. Because in the first lines, you ran subset mock before filtering, stoopid. Now everything has to be rerun :O
```

Normalize and fit kinetics:
```{r}
sars <- Normalize(sars)
sars <- FitKinetics(sars, "nlls")
```

Estimate regulation in the 2h snapshot:
```{r}
SetParallel()
sars <- EstimateRegulation(data = sars, name = "Regulation", contrasts = GetContrasts(sars, contrast = c("Condition","Mock"),group="duration.4sU",columns=Coldata(sars)$duration.4sU==2), reference.columns = FindReferences(sars, duration.4sU==0,group="Condition"), verbose = TRUE,
                              sample.f0.in.ss = TRUE)
saveRDS(sars, "regulation.fig5.rds")
```

Make the x and y axis for degradation rate changes:

```{r}
anal.table.sars <- GetAnalysisTable(sars)

all(rownames(anal.table.sars) %in% rownames(anal.table)) # FALSE

use.genes <- intersect(rownames(anal.table), rownames(anal.table.sars))

# Subset both tables based on use.genes
anal.table <- subset(anal.table, rownames(anal.table) %in% use.genes)
anal.table.sars <- subset(anal.table.sars, rownames(anal.table.sars) %in% use.genes)

all(rownames(anal.table) == rownames(anal.table.sars)) # TRUE

# Let's say x axis is full time course and y axis is snapshot
# Full time course
delta.x <- log2(anal.table.sars$`nlls.Mock.Half-life`/anal.table.sars$`nlls.SARS.Half-life`)

# 2h snapshot
delta.y <- anal.table.sars$`Regulation.SARS vs Mock.2.HL.log2FC`
```

Fig5:

```{r}
df.delta <- cbind(delta.x, delta.y)
PlotScatter(df.delta) + xlab("full time course") + ylab("snapshot 2h") + ggtitle("log FC degradation rate")
```

