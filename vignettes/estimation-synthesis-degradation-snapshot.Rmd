---
title: "Estimation of synthesis and degradation rates from snapshot experiments"
author: "Lygeri Sakellaridi"
date: "6/30/2022"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Kinetic modeling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Synthesis and degradation can be estimated from a single time point in an 
unbiased way and without assuming steady state. In this vignette we explore how.

Throughout the vignette, "sigma" and "delta" are used as short terms for
"synthesis rate" and "degradation rate" respectively.

# Data simulation

We simulate a data set based on the SARS-CoV-2 data set from Finkel et al. 2021
[[3]](https://www.nature.com/articles/s41586-021-03610-3). The data set contains 
time series samples from the human epithelial cell line (Calu3 cells); half of 
the samples were infected with SARS-CoV-2 for different periods of time.

In the mock samples, we perturb synthesis (sigma) or degradation (delta) rate.
We also leave a simulation unperturbed as control. We simulate three replicates
from the 2h time point.

```{r}
suppressPackageStartupMessages({library(grandR)})
if (!file.exists("snapshot.est.step1.rds")) {
  
 
sars <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz",
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
sars <- subset(sars,columns=Condition(sars)=="Mock")
sars <- FilterGenes(sars)
sars <- Normalize(sars)
SetParallel()
sars <- FitKinetics(sars,type="nlls")
seed = 1337
f0 <- GetAnalysisTable(sars)$kinetics.Mock.Synthesis/log(2)*GetAnalysisTable(sars)$`kinetics.Mock.Half-life`
control <- SimulateTimeCourse("control", GeneInfo(sars),
                           s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis,
                           d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life`,
                           dispersion = estimate.dispersion(GetTable(sars,type="count")),
                           f0 = f0,
                           s.variation = 1.05,
                           d.variation = 1.05,
                           timepoints = c(2, 2, 2),
                           beta.approx = TRUE, num.reads = 5E7, seed = seed)
unperturbed <- SimulateTimeCourse("unperturbed", GeneInfo(sars),
                                 s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis,
                                 d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life`,
                                 dispersion=estimate.dispersion(GetTable(sars,type="count")),
                                 f0 = f0,s.variation = 1.05,d.variation = 1.05,timepoints = c(2,2,2),
                                 beta.approx = TRUE,
                                 num.reads=5E7,
                                 seed=seed*13)
perturbed.d <- SimulateTimeCourse("HL", GeneInfo(sars),
                                 s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis,
                                 d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life` *2^rnorm(nrow(sars),0,1) ,
                                 dispersion = estimate.dispersion(GetTable(sars,type="count")),
                                 f0 = f0, s.variation = 1.05, d.variation = 1.05,
                                 timepoints = c(2,2,2),beta.approx = TRUE,
                                 num.reads=5E7, seed = seed*13*13)
perturbed.s <- SimulateTimeCourse("s", GeneInfo(sars),
                                 s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis *2^rnorm(nrow(sars),0,1) ,
                                 d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life`,
                                 dispersion = estimate.dispersion(GetTable(sars,type="count")),
                                 f0 = f0, s.variation = 1.05, d.variation = 1.05,
                                 timepoints = c(2,2,2),
                                 beta.approx = TRUE, num.reads = 5E7,
                                 seed=seed*13*13*13)

saveRDS(control, "reg.control.rds")
saveRDS(unperturbed, "reg.unperturbed.rds")
saveRDS(perturbed.s, "reg.perturbed.s.rds")
saveRDS(perturbed.d, "reg.perturbed.d.rds")

m <- merge(control = control, unperturbed = unperturbed, perturbed.d = perturbed.d, perturbed.s = perturbed.s)
# In GeneInfo, they will be called true_d.name, true_s.name
saveRDS(m, "regulation.step1.rds")
} else {
  m <- readRDS("regulation.step1.rds")
} 

```

All simulations used in these vignette, as well as equivalent simulations for 
the 1h and 4h time points, are available here (insert Internet location).

# Testing causes of log-fold change (LFC) between conditions in old and new RNA

To estimate sigma and delta, we can use the following equations:

(3)

(4)

Two theoretical considerations stem from these equations: 

1. A LFC in the old RNA between conditions means that either the
RNA labels before labeling were already different, or that delta differs by
an additive constant rather than a multiplicative factor.

To test this, we compare the LFC between the control and the simulation with 
pertubed delta:

```{r}
# Get LFC values for old RNA
m <- LFC(m, "old", GetContrasts(m, contrast = c("Condition","control")), mode="old")

# Get analysis table
anal.table <-GetAnalysisTable(m)

a <- GeneInfo(m)$true_d
b <- GeneInfo(m)$true_d.perturbed.d
lfc.perturbed.d.vs.control.old <- log2(a/b)
lfc.unperturbed.vs.control.old <- anal.table$`old.HL vs control.LFC`

# Put LFC of unpertubed vs pertubed delta in a dataframe
df.old <- data.frame(cbind(lfc.perturbed.d.vs.control.old, lfc.unperturbed.vs.control.old))

# Use PlotScatter
PlotScatter(df.old)
```

We can see there is no linear correlation (can we though?), which is expected 
from old RNA LFC resulting from an additive change in delta.

2. A LFC in new RNA, previously associated with changes in sigma, can also be
due to changes in delta. This is especially true for genes with short-lived
RNA.

To test this, we plotted delta-induced LFC for new RNA, with an emphasis
on short-lived genes. For this example, we consider "short-lived" to mean
"with a half-life <= 1 h", but we encourage users to experiment with different
cutoffs.

First, we will make a list that contains all the names of short-lived genes.
In order to do this, we will extract the true values for delta from the analysis
table of our grandR object and then convert them to half-lives using the 
following equation from [REF: grand-slam paper]:

(9)

```{r}
m <- LFC(m, "new", GetContrasts(m, contrast = c("Condition","control")), mode = "new")
anal.table <- GetAnalysisTable(m)
threshold <- 1 # our half-life threshold for short-lived genes
hl <- log(2)/anal.table$true_d
genes <- rownames(anal.table)
short.lived.genes <- genes[hl <= threshold]
```

Now we can make our scatter plot:

```{r}
lfc.perturbed.d.vs.control.new <- log2(GeneInfo(m)$true_d/GeneInfo(m)$true_d.perturbed.d)
lfc.unperturbed.vs.control.new <- anal.table$`new.HL vs control.LFC`

df.new <- data.frame(cbind(lfc.perturbed.d.vs.control.new, 
                           lfc.unperturbed.vs.control.new))
rownames(df.new) <- rownames(anal.table) # add gene names to data frame

# PlotScatter, new RNA unpertubed vs pertubed delta LFC
PlotScatter(df.new, highlight = short.lived.genes)
```

We can see there are significant LFCs for short-lived genes when delta
(but not sigma) is changed. (Kind of? There are all these genes that are
close to 0 for both.)

# Unbiased estimation of synthesis and degradation rates

We have seen that it is possible to estimate sigma and delta from equations
(3) and (4). However, these estimates can be inaccurate due to technical
factors (eg low number of reads) as well as subject to biological variability
between replicates.

To estimate sigma and delta without the bias introduced by these factors, we 
apply a Bayesian hierarchical model:

```{r}
# Add total RNA
m <- LFC(m,"total", GetContrasts(m, contrast = c("Condition","control")), mode="total")

# EstimateRegulation
m <- Normalize(m)

SetParallel()
m <- EstimateRegulation(m, "Regulation", contrasts = GetContrasts(m, contrast = c("Condition","control")), reference.columns = FindReferences(m, Condition == "control", group = NULL),verbose = TRUE, sample.f0.in.ss = TRUE)

saveRDS(m, "regulation.step2.rds")

# Get new analysis table and take a look at the columns
anal.table.reg <- GetAnalysisTable(m)
colnames(anal.table.reg)

# PlotScatter on estimates vs true sigma/delta; slope should be 1, meaning no bias

true.s.lfc <- log2(GeneInfo(m)$true_s.perturbed.s/GeneInfo(m)$true_s)
est.s.lfc <- anal.table.reg$`Regulation.s vs control.s.log2FC`

true.hl.lfc <- -log2(GeneInfo(m)$true_d.perturbed.d/GeneInfo(m)$true_d)
est.hl.lfc <- anal.table.reg$`Regulation.HL vs control.HL.log2FC`

df.hl <- data.frame(cbind(true.hl.lfc, est.hl.lfc))
df.s <- data.frame(cbind(true.s.lfc, est.s.lfc))


# Also try separately after filtering genes (reads) and for the top and bottom
# 10% of genes in terms of half-life
```

Plotting the estimates of sigma and delta against their true values results 
in a scatterplot with a slope equal to (approaching?) one, indicating that
the estimates are unbiased:

```{r}
PlotScatter(df.hl, label = (paste0("slope==", coef(lm(df.hl$est.hl.lfc~df.hl$true.hl.lfc))))) # unsuccessful attempt to include slope in plot
```

```{r}
PlotScatter(df.s, label = (paste0("slope==", coef(lm(df.s$est.s.lfc~df.s$true.s.lfc))))) # unsuccessful attempt to include slope in plot
```

Something something filter genes and try again. 

Something something do again for top and bottom 10% of half-lives.

We also observe that sigma and delta are small for the unperturbed simulations.
and that the variance for delta is substantially larger than the variance for 
sigma:

```{r}
# Insert boxplots here
# Plotting the following distributions:

# Changes in delta
par(mfrow = c(1, 3))
boxplot(anal.table.reg$`Regulation.unperturbed vs control.HL.log2FC`) 
boxplot(anal.table.reg$`Regulation.HL vs control.HL.log2FC`)
boxplot(anal.table.reg$`Regulation.s vs control.HL.log2FC`)
```

```{r}
# Changes in sigma
# Use ggplot and make sure y axis is same
# Filter for highly expressed genes (higher threshold for this step, optionally for others: 3000-4000 genes)

par(mfrow = c(1, 3))
boxplot(anal.table.reg$`Regulation.unperturbed vs control.s.log2FC`)
boxplot(anal.table.reg$`Regulation.HL vs control.s.log2FC`)
boxplot(anal.table.reg$`Regulation.s vs control.s.log2FC`)
```

# Region of practical equivalence (ROPE) analysis outperforms DESeq2

Our Bayesian model also gives us the marginal posterior distributions for
sigma and delta. It is worth noting that these distributions accurately cover
deviations from ground truth, which means that they really reflect measurement
uncertainty:

```{r}
# region between hl.conf.lower and hl.conf.upper
# 95% of values are between lower and upper
# the conf thing will be changed to cred
# Behold, a plot
```

This allows us to perform ROPE analysis [reference] to quantify significant
changes in sigma and delta, and compare the results to those of the frequentist
approach as implemented in DESeq2.

```{r}
# EstimateRegulation already gave ROPE output, let's do DESeq
# PairwiseDESEq() instead of LikelihoodRatioTest
# compute deseq2 values for new rna perturbed.s vs control
# ground truth for roc: log2(GeneInfo(m)$true_s.perturbed.s/GeneInfo(m)$true_s.control)
# if this is smaller than -0.25 or higher than 0.25, it's true
# vector with true/false + vector with numbers that define an ordering
m <- LikelihoodRatioTest(m, name = "LRT.old", mode = "old")
m <- LikelihoodRatioTest(m, name = "LRT.new", mode = "new")
```

ROPE outperforms DEseq2 as evidenced by ROC analysis.

```{r}
# Insert ROC analysis
```

# Comparison of degradation rate changes: full time course versus snapshot

We compare delta between a snapshot from a single time point (2h) versus a
full time course.

```{r}
# Code
```

They're basically the same.
