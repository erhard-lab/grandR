---
title: "Estimation of synthesis and degradation rates from snapshot experiments"
author: "Lygeri Sakellaridi"
date: "6/30/2022"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Kinetic modeling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Synthesis and degradation can be estimated from a single time point in an 
unbiased way and without assuming steady state. In this vignette we explore how.

Throughout the vignette, "sigma" and "delta" are used as short terms for
"synthesis rate" and "degradation rate" respectively.

# Data simulation

We simulate a data set based on the SARS-CoV-2 data set from Finkel et al. 2021
[[3]](https://www.nature.com/articles/s41586-021-03610-3). The data set contains 
time series samples from the human epithelial cell line (Calu3 cells); half of 
the samples were infected with SARS-CoV-2 for different periods of time.

In the mock samples, we perturb synthesis (sigma) or degradation (delta) rate.
We also leave a simulation unperturbed as control. We simulate three replicates
from the 2h time point.

```{r}
suppressPackageStartupMessages({library(grandR)})
if (!file.exists("snapshot.est.step1.rds")) {
  
 
sars <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz",
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
sars <- subset(sars,columns=Condition(sars)=="Mock")
sars <- FilterGenes(sars)
sars <- Normalize(sars)
SetParallel()
sars <- FitKinetics(sars,type="nlls")
seed = 1337
f0 <- GetAnalysisTable(sars)$kinetics.Mock.Synthesis/log(2)*GetAnalysisTable(sars)$`kinetics.Mock.Half-life`
control <- SimulateTimeCourse("control", GeneInfo(sars),
                           s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis,
                           d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life`,
                           dispersion = estimate.dispersion(GetTable(sars,type="count")),
                           f0 = f0,
                           s.variation = 1.05,
                           d.variation = 1.05,
                           timepoints = c(2, 2, 2),
                           beta.approx = TRUE, num.reads = 5E7, seed = seed)
unperturbed <- SimulateTimeCourse("unperturbed", GeneInfo(sars),
                                 s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis,
                                 d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life`,
                                 dispersion=estimate.dispersion(GetTable(sars,type="count")),
                                 f0 = f0,s.variation = 1.05,d.variation = 1.05,timepoints = c(2,2,2),
                                 beta.approx = TRUE,
                                 num.reads=5E7,
                                 seed=seed*13)
perturbed.d <- SimulateTimeCourse("HL", GeneInfo(sars),
                                 s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis,
                                 d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life` *2^rnorm(nrow(sars),0,1) ,
                                 dispersion = estimate.dispersion(GetTable(sars,type="count")),
                                 f0 = f0, s.variation = 1.05, d.variation = 1.05,
                                 timepoints = c(2,2,2),beta.approx = TRUE,
                                 num.reads=5E7, seed = seed*13*13)
perturbed.s <- SimulateTimeCourse("s", GeneInfo(sars),
                                 s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis *2^rnorm(nrow(sars),0,1) ,
                                 d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life`,
                                 dispersion = estimate.dispersion(GetTable(sars,type="count")),
                                 f0 = f0, s.variation = 1.05, d.variation = 1.05,
                                 timepoints = c(2,2,2),
                                 beta.approx = TRUE, num.reads = 5E7,
                                 seed=seed*13*13*13)

saveRDS(control, "reg.control.rds")
saveRDS(unperturbed, "reg.unperturbed.rds")
saveRDS(perturbed.s, "reg.perturbed.s.rds")
saveRDS(perturbed.d, "reg.perturbed.d.rds")

m <- merge(control = control, unperturbed = unperturbed, perturbed.d = perturbed.d, perturbed.s = perturbed.s)
# In GeneInfo, they will be called true_d.name, true_s.name
saveRDS(m, "regulation.step1.rds")
} else {
  m <- readRDS("regulation.step1.rds")
} 

```

All simulations used in these vignette, as well as equivalent simulations for 
the 1h and 4h time points, are available here (insert Internet location).

# Testing causes of log-fold change (LFC) between conditions in old and new RNA

To estimate sigma and delta, we can use the following equations:

(3)

(4)

Two theoretical considerations stem from these equations: 

1. A LFC in the old RNA between conditions means that either the
RNA labels before labeling were already different, or that delta differs by
an additive constant rather than a multiplicative factor.

To test this, we compare the LFC between the control and the simulation with 
pertubed delta:

```{r}
# Get LFC values for old RNA
m <- LFC(m, "old", GetContrasts(m, contrast = c("Condition","control")), mode="old")

# Get analysis table
anal.table <- GetAnalysisTable(m)

a <- GeneInfo(m)$true_d
b <- GeneInfo(m)$true_d.perturbed.d
lfc.perturbed.d.vs.control.old <- log2(a/b)
lfc.unperturbed.vs.control.old <- anal.table$`old.HL vs control.LFC`

# Put LFC of unpertubed vs pertubed delta in a dataframe
df.old <- data.frame(cbind(lfc.perturbed.d.vs.control.old, lfc.unperturbed.vs.control.old))

# Use PlotScatter
PlotScatter(df.old, remove.outlier = 999)
```

We can see there is no linear correlation (can we though?), which is expected 
from old RNA LFC resulting from an additive change in delta.

2. A LFC in new RNA, previously associated with changes in sigma, can also be
due to changes in delta. This is especially true for genes with short-lived
RNA.

To test this, we plotted delta-induced LFC for new RNA, with an emphasis
on short-lived genes. For this example, we consider "short-lived" to mean
"with a half-life <= 1 h", but we encourage users to experiment with different
cutoffs.

First, we will make a list that contains all the names of short-lived genes.
In order to do this, we will extract the true values for delta from the analysis
table of our grandR object and then convert them to half-lives using the 
following equation from [REF: grand-slam paper]:

(9)

```{r}
m <- LFC(m, "new", GetContrasts(m, contrast = c("Condition","control")), mode = "new")
anal.table <- GetAnalysisTable(m)
threshold <- 1 # our half-life threshold for short-lived genes
hl <- log(2)/anal.table$true_d
genes <- rownames(anal.table)
short.lived.genes <- genes[hl <= threshold]
```

Now we can make our scatter plot:

```{r}
lfc.perturbed.d.vs.control.new <- log2(GeneInfo(m)$true_d/GeneInfo(m)$true_d.perturbed.d)
lfc.unperturbed.vs.control.new <- anal.table$`new.HL vs control.LFC`

df.new <- data.frame(cbind(lfc.perturbed.d.vs.control.new, 
                           lfc.unperturbed.vs.control.new))
rownames(df.new) <- rownames(anal.table) # add gene names to data frame

# PlotScatter, new RNA unpertubed vs pertubed delta LFC
PlotScatter(df.new, highlight = short.lived.genes, remove.outlier = 999)
```

We can see there are significant LFCs for short-lived genes when delta
(but not sigma) is changed. 

# Unbiased estimation of synthesis and degradation rates

We have seen that it is possible to estimate sigma and delta from equations
(3) and (4). However, these estimates can be inaccurate due to technical
factors (eg low number of reads) as well as subject to biological variability
between replicates.

To estimate sigma and delta without the bias introduced by these factors, we 
apply a Bayesian hierarchical model:

```{r}
# Add total RNA
m <- LFC(m,"total", GetContrasts(m, contrast = c("Condition","control")), mode="total")

# EstimateRegulation
m <- Normalize(m)

SetParallel()
m <- EstimateRegulation(m, "Regulation", contrasts = GetContrasts(m, contrast = c("Condition","control")), reference.columns = FindReferences(m, Condition == "control", group = NULL),verbose = TRUE, sample.f0.in.ss = TRUE)

saveRDS(m, "regulation.step2.rds")

# Get new analysis table and take a look at the columns
anal.table <- GetAnalysisTable(m)
colnames(anal.table)

# PlotScatter on estimates vs true sigma/delta; slope should be 1, meaning no bias

true.s.lfc <- log2(GeneInfo(m)$true_s.perturbed.s/GeneInfo(m)$true_s)
est.s.lfc <- anal.table$`Regulation.s vs control.s.log2FC`

true.hl.lfc <- -log2(GeneInfo(m)$true_d.perturbed.d/GeneInfo(m)$true_d)
est.hl.lfc <- anal.table$`Regulation.HL vs control.HL.log2FC`

df.hl <- data.frame(cbind(true.hl.lfc, est.hl.lfc))
df.s <- data.frame(cbind(true.s.lfc, est.s.lfc))
```

Plotting the estimates of sigma and delta against their true values results 
in a scatterplot with a slope close to 1, indicating that the estimates are 
unbiased:

```{r}
PlotScatter(df.hl, remove.outlier = 999) + geom_abline()
```

```{r}
PlotScatter(df.s, remove.outlier = 999) + geom_abline() # unsuccessful attempt to include slope in plot
```

It is interesting to explore how these plots change if we only maintain
highly expressed genes. We can set different thresholds for expression by
using the FilterGenes command and playing with the number of reads and samples.
As an example, we show how the plots are affected if we keep reads that have
at least 4000 reads in at least half of the samples. These thresholds maintain
3020 genes.

```{r}
m2 <- FilterGenes(m, type = "count", minval = 4000)
nrow(GeneInfo(m2))
```
We repeat the dataframe-making steps for the m2 object:

```{r}
# Get new analysis table and take a look at the columns
anal.table2 <- GetAnalysisTable(m2)
colnames(anal.table2)

# PlotScatter on estimates vs true sigma/delta; slope should be 1, meaning no bias

true.s.lfc.filtered <- log2(GeneInfo(m2)$true_s.perturbed.s/GeneInfo(m2)$true_s)
est.s.lfc.filtered <- anal.table2$`Regulation.s vs control.s.log2FC`

true.hl.lfc.filtered <- -log2(GeneInfo(m2)$true_d.perturbed.d/GeneInfo(m2)$true_d)
est.hl.lfc.filtered <- anal.table2$`Regulation.HL vs control.HL.log2FC`

df.hl2 <- data.frame(cbind(true.hl.lfc.filtered, est.hl.lfc.filtered))
df.s2 <- data.frame(cbind(true.s.lfc.filtered, est.s.lfc.filtered))
```

Then we remake the plots for half-life:

```{r}
PlotScatter(df.hl2, label = (paste0("slope==", coef(lm(df.hl2$est.hl.lfc.filtered~df.hl2$true.hl.lfc.filtered))))) # unsuccessful attempt to include slope in plot
```

(It's just similar but less dense)

And sigma:

```{r}
PlotScatter(df.s2, label = (paste0("slope==", coef(lm(df.s2$est.s.lfc.filtered~df.s2$true.s.lfc.filtered))))) # unsuccessful attempt to include slope in plot
```
We also observe that sigma and delta are small for the unperturbed simulations, and that the variance for delta is substantially larger than the variance for sigma:

```{r}
library(ggplot2)
library(reshape2)
box.hl <- data.frame(unperturbed.vs.control = anal.table$`Regulation.unperturbed vs control.HL.log2FC`,
                     hl.vs.control = anal.table$`Regulation.HL vs control.HL.log2FC`,
                     s.vs.control = anal.table$`Regulation.s vs control.HL.log2FC`)

box.hl.molten <- melt(box.hl)

ggplot(box.hl.molten, aes(x = variable, y = value)) +
  geom_boxplot()
```
Sigma: 

```{r}
box.s <- data.frame(unperturbed.vs.control = anal.table$`Regulation.unperturbed vs control.s.log2FC`,
                     hl.vs.control = anal.table$`Regulation.HL vs control.s.log2FC`,
                     s.vs.control = anal.table$`Regulation.s vs control.s.log2FC`)

box.s.molten <- melt(box.s)

ggplot(box.s.molten, aes(x = variable, y = value)) +
  geom_boxplot()
```
Once again, we can explore how these plots are affected by gene filtering.

Half-life:

```{r}
box.hl.filtered <- data.frame(unperturbed.vs.control = anal.table2$`Regulation.unperturbed vs control.HL.log2FC`,
                     hl.vs.control = anal.table2$`Regulation.HL vs control.HL.log2FC`,
                     s.vs.control = anal.table2$`Regulation.s vs control.HL.log2FC`)

box.hl.molten.filtered <- melt(box.hl.filtered)

ggplot(box.hl.molten.filtered, aes(x = variable, y = value)) +
  geom_boxplot()
```

Sigma:

```{r}
box.s.filtered <- data.frame(unperturbed.vs.control = anal.table2$`Regulation.unperturbed vs control.s.log2FC`,
                     hl.vs.control = anal.table2$`Regulation.HL vs control.s.log2FC`,
                     s.vs.control = anal.table2$`Regulation.s vs control.s.log2FC`)

box.s.molten.filtered <- melt(box.s.filtered)

ggplot(box.s.molten.filtered, aes(x = variable, y = value)) +
  geom_boxplot()
```

# Filter based on half-life (in control). Expectation: too short and too long
# are both bad.

It is also of interest to explore how the plots change if we keep only
short-lived or only long-lived genes. To test this, we will first get 
the gene names and half-lives from the analysis table and store the 
result into a new dataframe:

```{r}
anal.small <- data.frame(log(2)/anal.table$true_d)
rownames(anal.small) <- rownames(anal.table)
colnames(anal.small) <- "gene.halflife"
```

Then we will order the new dataframe based on (ascending) half-life:

```{r}
anal.small.ordered <- anal.small[order(anal.small$gene.halflife), , drop = FALSE]
```

To reconstruct the plots, we will consider the top and bottom 10% of genes in terms of half-life. This amounts to approximately 1084 from each side of
the dataframe:

```{r}
nrow(anal.small.ordered) # 10835 genes; 10% is 1083.5, roughly 1084
top10percent.halflife.genes <- rownames(tail(anal.small.ordered, 1084))
bottom10percent.halflife.genes <- rownames(head(anal.small.ordered, 1084))
```

We will make subsets of the GeneInfo table and the analysis table of our simulated object based on these gene sets:

```{r}
gene.info <- GeneInfo(m)
rownames(gene.info) <- gene.info$Symbol

top10percent.hl.geneinfo <- subset(gene.info, rownames(gene.info) %in% top10percent.halflife.genes)

bottom10percent.hl.geneinfo <- subset(gene.info, rownames(gene.info) %in% bottom10percent.halflife.genes)

top10percent.hl.analtable <- subset(anal.table, rownames(anal.table) %in%
                                      top10percent.halflife.genes)
bottom10percent.hl.analtable <- subset(anal.table, rownames(anal.table) %in%
                                      bottom10percent.halflife.genes)

# Sanity checks
all(rownames(top10percent.hl.geneinfo) == rownames(top10percent.hl.analtable))
all(rownames(bottom10percent.hl.geneinfo) == rownames(bottom10percent.hl.analtable))
nrow(top10percent.hl.analtable)
nrow(top10percent.hl.geneinfo)
```
Finally, we can redo the plots.

Dataframe-making code for scatterplots:

```{r}
# PlotScatter on estimates vs true sigma/delta

# top 10%
true.s.lfc.top10percent.hl <- top10percent.hl.geneinfo$true_s.perturbed.s/top10percent.hl.geneinfo$true_s 

est.s.lfc.top10percent.hl <- top10percent.hl.analtable$`Regulation.s vs control.s.log2FC`

true.hl.lfc.top10percent.hl <- -log2(top10percent.hl.geneinfo$true_d.perturbed.d/top10percent.hl.geneinfo$true_d) 
est.hl.lfc.top10percent.hl <- top10percent.hl.analtable$`Regulation.HL vs control.HL.log2FC`

df.hl.top10percent.hl <- data.frame(cbind(true.hl.lfc.top10percent.hl, est.hl.lfc.top10percent.hl))
df.s.top10percent.hl <- data.frame(cbind(true.s.lfc.top10percent.hl, est.s.lfc.top10percent.hl))

# bottom 10%
true.s.lfc.bottom10percent.hl <- bottom10percent.hl.geneinfo$true_s.perturbed.s/bottom10percent.hl.geneinfo$true_s 

est.s.lfc.bottom10percent.hl <- bottom10percent.hl.analtable$`Regulation.s vs control.s.log2FC`

true.hl.lfc.bottom10percent.hl <- -log2(bottom10percent.hl.geneinfo$true_d.perturbed.d/bottom10percent.hl.geneinfo$true_d) 
est.hl.lfc.bottom10percent.hl <- bottom10percent.hl.analtable$`Regulation.HL vs control.HL.log2FC`

df.hl.bottom10percent.hl <- data.frame(cbind(true.hl.lfc.bottom10percent.hl, est.hl.lfc.bottom10percent.hl))
df.s.bottom10percent.hl <- data.frame(cbind(true.s.lfc.bottom10percent.hl, est.s.lfc.bottom10percent.hl))
```

Then we remake the plots for half-life:

Top 10%:

```{r}
PlotScatter(df.hl.top10percent.hl)
```

Bottom 10%:

```{r}
PlotScatter(df.hl.bottom10percent.hl)
```

And synthesis rate: 

Top 10%:

```{r}
PlotScatter(df.s.top10percent.hl)
```

Bottom 10%:

```{r}
PlotScatter(df.s.bottom10percent.hl)
```

Boxplots:

Delta (top 10%):

```{r}
box.hl.top10percent.hl <- data.frame(unperturbed.vs.control = top10percent.hl.analtable$`Regulation.unperturbed vs control.HL.log2FC`,
                     hl.vs.control = top10percent.hl.analtable$`Regulation.HL vs control.HL.log2FC`,
                     s.vs.control = top10percent.hl.analtable$`Regulation.s vs control.HL.log2FC`)

box.hl.molten.top10percent.hl <- melt(box.hl.top10percent.hl)

ggplot(box.hl.molten.top10percent.hl, aes(x = variable, y = value)) +
  geom_boxplot()
```

Delta (bottom 10%):

```{r}
box.hl.bottom10percent.hl <- data.frame(unperturbed.vs.control = bottom10percent.hl.analtable$`Regulation.unperturbed vs control.HL.log2FC`,
                     hl.vs.control = bottom10percent.hl.analtable$`Regulation.HL vs control.HL.log2FC`,
                     s.vs.control = bottom10percent.hl.analtable$`Regulation.s vs control.HL.log2FC`)

box.hl.molten.bottom10percent.hl <- melt(box.hl.bottom10percent.hl)

ggplot(box.hl.molten.bottom10percent.hl, aes(x = variable, y = value)) +
  geom_boxplot()
```
Sigma (top 10%):

```{r}
box.s.top10percent.hl <- data.frame(unperturbed.vs.control = top10percent.hl.analtable$`Regulation.unperturbed vs control.s.log2FC`,
                     hl.vs.control = top10percent.hl.analtable$`Regulation.HL vs control.s.log2FC`,
                     s.vs.control = top10percent.hl.analtable$`Regulation.s vs control.s.log2FC`)

box.s.molten.top10percent.hl <- melt(box.s.top10percent.hl)

ggplot(box.s.molten.top10percent.hl, aes(x = variable, y = value)) +
  geom_boxplot()
```

Sigma (bottom 10%):

```{r}
box.s.bottom10percent.hl <- data.frame(unperturbed.vs.control = bottom10percent.hl.analtable$`Regulation.unperturbed vs control.s.log2FC`,
                     hl.vs.control = bottom10percent.hl.analtable$`Regulation.HL vs control.s.log2FC`,
                     s.vs.control = bottom10percent.hl.analtable$`Regulation.s vs control.s.log2FC`)

box.s.molten.bottom10percent.hl <- melt(box.s.bottom10percent.hl)

ggplot(box.s.molten.bottom10percent.hl, aes(x = variable, y = value)) +
  geom_boxplot()
```

# Region of practical equivalence (ROPE) analysis outperforms DESeq2

Our Bayesian model also gives us the marginal posterior distributions for
sigma and delta. It is worth noting that these distributions accurately cover
deviations from ground truth, which means that they really reflect measurement
uncertainty:

```{r}
# region between hl.conf.lower and hl.conf.upper
# 95% of values (log2(true_s.perturbed.s/true_s), 
# log2(true_d.perturbed.d/true_d)) are between lower and upper
# the conf thing will be changed to cred
# Behold, a plot
```

This allows us to perform ROPE analysis [reference] to quantify significant
changes in sigma and delta, and compare the results to those of the frequentist
approach as implemented in DESeq2.

```{r}
# EstimateRegulation already gave ROPE output, let's do DESeq
# PairwiseDESEq() instead of LikelihoodRatioTest
# compute deseq2 values for new rna perturbed.s vs control
# ground truth for roc: log2(GeneInfo(m)$true_s.perturbed.s/GeneInfo(m)$true_s.control)
# if this is smaller than -0.25 or higher than 0.25, it's true
# vector with true/false + vector with numbers that define an ordering
m <- PairwiseDESeq2(m, "new", GetContrasts(m, contrast = c("Condition","control")), mode = "new",verbose=T)
m <- PairwiseDESeq2(m, "old", GetContrasts(m, contrast = c("Condition","control")), mode="old",verbose=T)
saveRDS(m, "regulation.step3.rds")
anal.table <- GetAnalysisTable(m)
colnames(anal.table)
```

ROPE outperforms DEseq2 as evidenced by ROC analysis.

```{r}
# Insert ROC analysis
library(pROC)

# input: data frame
roc.rope <- roc(abs(log2(anal.table$true_d/anal.table$true_d.perturbed.d)) >= 0.25, 
               anal.table$`Regulation.HL vs control.HL.ROPE`) 
roc.deseq <- roc(abs(log2(anal.table$true_d/anal.table$true_d.perturbed.d)) >= 0.25, 
               anal.table$`old.HL vs control.P`) 
ggroc(list(roc.rope, roc.deseq))

roc.rope.new <- roc(abs(log2(anal.table$true_s/anal.table$true_s.perturbed.s)) >= 0.25, 
               anal.table$`Regulation.s vs control.s.ROPE`) 
roc.deseq.new <- roc(abs(log2(anal.table$true_s/anal.table$true_s.perturbed.s)) >= 0.25, 
               anal.table$`new.s vs control.P`) 
ggroc(list(roc.rope.new, roc.deseq.new))

# is abs(log2(true_d/true_d.perturbed.d)) > 0.25 LFC -> is regulated
# predictor (rope): regulation.HL vs control.HL.ROPE
# predictor (deseq): p-value (old.d.vs.control.P)
# the package will calculate the confusion matrix :p
# (same for s)
# (same for new rna)
# (same analysis for the other perturbation)
# sensitivity vs 1 - specificity
```

# Comparison of degradation rate changes: full time course versus snapshot

We compare delta between a snapshot from a single time point (2h) versus a
full time course.

```{r}
# Code
```

They're basically the same.
