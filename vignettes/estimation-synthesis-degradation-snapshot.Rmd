---
title: "Estimation of synthesis and degradation rates from snapshot experiments"
author: "Lygeri Sakellaridi"
date: "6/30/2022"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Kinetic modeling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Synthesis and degradation can be estimated from a single time point in an 
unbiased way and without assuming steady state. In this vignette we explore how.

Throughout the vignette, "sigma" and "delta" are used as short terms for
"synthesis rate" and "degradation rate" respectively.

# Data simulation

We simulate a data set based on the SARS-CoV-2 data set from Finkel et al. 2021
[[3]](https://www.nature.com/articles/s41586-021-03610-3). The data set contains 
time series samples from the human epithelial cell line (Calu3 cells); half of 
the samples were infected with SARS-CoV-2 for different periods of time.

In the mock samples, we perturb synthesis (sigma) or degradation (delta) rate.
We also leave a simulation unperturbed as control. We simulate three replicates
from the 2h time point.

```{r}
suppressPackageStartupMessages({library(grandR)})
sars <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz",
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
sars <- subset(sars,columns=Condition(sars)=="Mock")
sars <- FilterGenes(sars)
sars <- Normalize(sars)
SetParallel()
sars <- FitKinetics(sars,type="nlls")
seed = 1337
f0 <- GetAnalysisTable(sars)$kinetics.Mock.Synthesis/log(2)*GetAnalysisTable(sars)$`kinetics.Mock.Half-life`
control <- SimulateTimeCourse("control", GeneInfo(sars),
                           s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis,
                           d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life`,
                           dispersion = estimate.dispersion(GetTable(sars,type="count")),
                           f0 = f0,
                           s.variation = 1.05,
                           d.variation = 1.05,
                           timepoints = c(2, 2, 2),
                           beta.approx = TRUE, num.reads = 5E7, seed = seed)
unperturbed <- SimulateTimeCourse("unperturbed", GeneInfo(sars),
                                 s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis,
                                 d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life`,
                                 dispersion=estimate.dispersion(GetTable(sars,type="count")),
                                 f0 = f0,s.variation = 1.05,d.variation = 1.05,timepoints = c(2,2,2),
                                 beta.approx = TRUE,
                                 num.reads=5E7,
                                 seed=seed*13)
perturbed.d <- SimulateTimeCourse("HL", GeneInfo(sars),
                                 s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis,
                                 d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life` *2^rnorm(nrow(sars),0,1) ,
                                 dispersion = estimate.dispersion(GetTable(sars,type="count")),
                                 f0 = f0, s.variation = 1.05, d.variation = 1.05,
                                 timepoints = c(2,2,2),beta.approx = TRUE,
                                 num.reads=5E7, seed = seed*13*13)
perturbed.s <- SimulateTimeCourse("s", GeneInfo(sars),
                                 s = GetAnalysisTable(sars)$kinetics.Mock.Synthesis *2^rnorm(nrow(sars),0,1) ,
                                 d = log(2)/GetAnalysisTable(sars)$`kinetics.Mock.Half-life`,
                                 dispersion = estimate.dispersion(GetTable(sars,type="count")),
                                 f0 = f0, s.variation = 1.05, d.variation = 1.05,
                                 timepoints = c(2,2,2),
                                 beta.approx = TRUE, num.reads = 5E7,
                                 seed=seed*13*13*13)


m <- merge(control, unperturbed, perturbed.d, perturbed.s)
saveRDS(m, "snapshot.est.step1.rds")
```

All simulations used in these vignette, as well as equivalent simulations for 
the 1h and 4h time points, are available here (insert Internet location).

# Testing causes of log-fold change (LFC) between conditions in old and new RNA

To estimate sigma and delta, we can use the following equations:

(3)

(4)

Two theoretical considerations stem from these equations: 

1. A LFC in the old RNA between conditions means that either the
RNA labels before labeling were already different, or that delta differs by
an additive constant rather than a multiplicative factor.

To test this, we compare the LFC between the control and the simulation with 
pertubed delta:

```{r}
# Get LFC values for old RNA
m <- LFC(m, "old", GetContrasts(m, contrast = c("Condition","control")), mode="old")

# Put LFC of unpertubed vs pertubed delta in a dataframe
anal.table <-GetAnalysisTable(m)
lfc.pertubed.d.vs.control.old <- anal.table$`old.HL vs control.LFC`
lfc.unperturbed.vs.control.old <- anal.table$`old.unperturbed vs control.LFC`
df.old <- data.frame(cbind(lfc.pertubed.d.vs.control.old, lfc.unperturbed.vs.control.old))

# Use PlotScatter
PlotScatter(df.old)
```

We can see there is no linear correlation, which is expected from old RNA LFC
resulting from an additive change in delta.

2. A LFC in new RNA, previously associated with changes in sigma, can also be
due to changes in delta. This is especially true for genes with short-lived
RNA.

To test this, we plotted delta-induced LFC for new RNA, with an emphasis
on short-lived genes. For this example, we consider "short-lived" to mean
"with a half-life <= 1 h", but we encourage users to experiment with different
cutoffs.

First, we will make a list that contains all the names of short-lived genes.
In order to do this, we will extract the true values for delta from the analysis
table of our grandR object and then convert them to half-lives using the 
following equation from [REF: grand-slam paper]:

(9)

```{r}
m <- LFC(m, "new", GetContrasts(m, contrast = c("Condition","control")), mode="new")
anal.table <- GetAnalysisTable(m)
threshold <- 1 # our half-life threshold for short-lived genes
hl <- log(2)/anal.table$true_d
genes <- rownames(anal.table)
short.lived.genes <- genes[hl <= threshold]
```

Now we can make our scatter plot:

```{r}
lfc.pertubed.d.vs.control.new <- anal.table$`new.HL vs control.LFC`
lfc.unperturbed.vs.control.new <- anal.table$`new.unperturbed vs control.LFC`
df.new <- data.frame(cbind(lfc.pertubed.d.vs.control.new, lfc.unperturbed.vs.control.new))
rownames(df.new) <- rownames(anal.table) # add gene names to data frame

# PlotScatter, new RNA unpertubed vs pertubed delta LFC
PlotScatter(df.new, highlight = short.lived.genes)
```

We can see there are significant LFCs for short-lived genes when delta
(but not sigma) is changed. (Nope)

# Unbiased estimation of synthesis and degradation rates

We have seen that it is possible to estimate sigma and delta from equations
(3) and (4). However, these estimates can be inaccurate due to technical
factors (eg low number of reads) as well as subject to biological variability
between replicates.

To estimate sigma and delta without the bias introduced by these factors, we 
apply a Bayesian hierarchical model:

```{r}
# Add total RNA
m <- LFC(m,"total", GetContrasts(m, contrast = c("Condition","control")), mode="total")

# EstimateRegulation
m <- Normalize(m)

SetParallel()
m <- EstimateRegulation(m, "Regulation", contrasts = GetContrasts(m,contrast = c("Condition","control")), reference.columns = FindReferences(m, Condition == "control", group = NULL),verbose = TRUE, sample.f0.in.ss = TRUE)

# Get new analysis table and take a look at the columns
anal.table.reg <- GetAnalysisTable(m)
colnames(anal.table.reg)

# PlotScatter on estimates vs true sigma/delta; slope should be 1, meaning no bias
# x is... my best guess is Regulation.unperturbed vs control.HL.LFC and Regulation.unperturbed vs control.s.LFC
# y is "Regulation.HL vs control.HL.log2FC" and "Regulation.s vs control.s.log2FC" 
true.s.lfc <- anal.table.reg$`Regulation.unperturbed vs control.s.log2FC`
true.hl.lfc <- anal.table.reg$`Regulation.unperturbed vs control.HL.log2FC`
est.s.lfc <- anal.table.reg$`Regulation.s vs control.s.log2FC`
est.hl.lfc <- anal.table.reg$`Regulation.HL vs control.HL.log2FC`

df.hl <- data.frame(cbind(true.hl.lfc, est.hl.lfc))
df.s <- data.frame(cbind(true.s.lfc, est.s.lfc))


# Also try separately after filtering genes (reads) and for the top and bottom
# 10% of genes in terms of half-life
```

Plotting the estimates of sigma and delta against their true values results 
in a scatterplot with a slope equal to (approaching?) one, indicating that
the estimates are unbiased:

```{r}
PlotScatter(df.hl, label = (paste0("slope==", coef(lm(df.hl$est.hl.lfc~df.hl$true.hl.lfc))))) # unsuccessful attempt to include slope in plot
```

```{r}
PlotScatter(df.s, label = (paste0("slope==", coef(lm(df.s$est.s.lfc~df.s$true.s.lfc))))) # unsuccessful attempt to include slope in plot
```

We also observe that sigma and delta are small for the unperturbed simulations.
and that the variance for delta is substantially larger than the variance for 
sigma:

```{r}
# Insert boxplots here
```

# Region of practical equivalence (ROPE) analysis outperforms DESeq2

Our Bayesian model also gives us the marginal posterior distributions for
sigma and delta. It is worth noting that these distributions accurately cover
deviations from ground truth, which means that they really reflect measurement
uncertainty:

```{r}
# Behold, a plot
```

This allows us to perform ROPE analysis [reference] to quantify significant
changes in sigma and delta, and compare the results to those of the frequentist
approach as implemented in DESeq2.

```{r}
# Behold, code
```

ROPE outperforms DEseq2 as evidenced by ROC analysis.

```{r}
# Insert ROC analysis
```

# Comparison of degradation rate changes: full time course versus snapshot

We compare delta between a snapshot from a single time point (2h) versus a
full time course.

```{r}
# Code
```

They're basically the same.


















