---
title: "Loading data and working with grandR objects"
output: 
  rmarkdown::html_vignette:
    toc: true
    df_print: kable
    fig_width: 7
    fig_height: 6
      
vignette: >
  %\VignetteIndexEntry{Loading data and working with grandR objects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,comment=NA,R.options=list(width = 95))
```

GRAND-R is an R package for the analysis of RNA-seq experiments involving 
metabolic RNA labeling with nucleotide conversion, such as SLAM-seq experiments [[1]] (https://doi.org/10.1038/nmeth.4435). In such experiments, nucleoside analogs such as 4sU are added to 
living cells, which take it up and incorporate it into newly synthesized RNA. Before sequencing, 4sU is converted into a cytosin analog. Reads covering 4sU sites therefore 
have characteristic T-to-C mismatches after read mapping, in principle providing the opportunity to differentiate newly synthesized (during the time of labeling) from pre-existing RNA. 

Confounders such as sequencing errors or reads that originate from newly synthesized RNA but, but chance, do not cover sites of 4sU incorporation (usually 20-80% of all new reads) can
be handeled using specialized methods such as GRAND-SLAM 
[[2]](https://doi.org/10.1093/bioinformatics/bty256).

# Reading in the data

Throughout this vignette, we will be using the GRAND-SLAM processed SLAM-seq data set
from Finkel et al. 2021 [[3]](https://www.nature.com/articles/s41586-021-03610-3). The data set contains time series (progressive labeling) samples from a human epithelial cell line (Calu3 cells); half of the samples were infected with SARS-CoV-2 for different periods of time. The input is a tsv file where rows are genes and columns are read counts and other statistics (e.g., the new-to-total RNA ratio) for all samples. The data set is available on zenodo
("https://zenodo.org/record/5834034/files/sars.tsv.gz")

```{r}
suppressPackageStartupMessages({library(grandR)})
sars <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz",
                  design=c(Design$Condition,Design$dur.4sU,Design$Replicate))
Columns(sars)
```
The design vector describes the experimental design. This assumes that sample
names are composed of three parts separated by dots as shown in the output. Note that the Columns function returns the sample names (or cell ids, if you load a single cell data set). Each part in the sample
name represents an aspect of the design. For example, the sample named Mock.2h.A is a sample from the mock condition (i.e. not infected by SARS-CoV-2), subjected to metabolic labeling for 2 hours, and is the first replicate (i.e. replicate "A"). This sample name is consistent with the design vector used above. It is possible to specify other design elements (of course the samples would have to be named accordingly). A list of reasonable options is predefined in the list `Design`. Some names have additional semantics. For example, for the name \emph{duration.4sU} the values are interpreted: e.g. 4h is converted into the number 4, 30min into 0.5, and no4sU into 0.

The design vector is mandatory. Attempting to read in the data without it
results in an error:

```{r error=TRUE}
sars <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz")
```

Alternatively, a table containing the metadata can be specified. Make sure that it contains a Name column matching the names in the GRAND-SLAM output table!
```{r}
metadata = data.frame(Name=c(
  "Mock.no4sU.A","Mock.1h.A","Mock.2h.A","Mock.2h.B","Mock.3h.A","Mock.4h.A",
  "SARS.no4sU.A","SARS.1h.A","SARS.2h.A","SARS.2h.B","SARS.3h.A","SARS.4h.A"
  ),Condition=rep(c("Mock","SARS"),each=6))
sars.meta <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz",design=metadata)
```


# What is in the grandR object

The grandR object contains

1. metadata for genes
2. metadata for samples/cells (as inferred from the sample names by the design parameter)
3. all data matrices (counts, normalized counts, ntrs, etc. these types of data are called "slots")
4. analysis results

Metadata (1. and 2.) are described below. How to work with the data matrices and analysis results is described in a separate vignette.

## Working with grandR objects


A short summmary as well can be displayed when printing the object, and there are several functions to retrieve general information about the object:
```{r}
print(sars)
Title(sars)
VersionString(sars)
nrow(sars)
ncol(sars)
```
Genes can be filtered:
```{r}
sars <- FilterGenes(sars)
nrow(sars)
```
By default genes are retained, if they have 100 read counts in at least half of the columns (i.e. samples or cells). There are many options how to filter by genes:

```{r}
cat(sprintf("Genes with at least 1000 read counts in half of the columns: %d\n",
            nrow(FilterGenes(sars,minval=1000))))
cat(sprintf("Genes with at least 1000 read counts in half of the columns (retain two genes that are otherwise filtered): %d\n",
            nrow(FilterGenes(sars,minval=1000,keep=c("ATF3","ZC3H12A")))))

cat(sprintf("Keep only these two genes: %d\n",
            nrow(FilterGenes(sars,use=c("ATF3","ZC3H12A")))))

sars <- NormalizeTPM(sars)     # compute transcript per million
cat(sprintf("Genes with at least 10 TPM in half of the columns: %d\n",
            nrow(FilterGenes(sars,mode.slot="tpm",minval=10))))
```
Also the columns can be filtered, this is done using the subset function:
```{r}
mock <- subset(sars,columns = Condition=="Mock")
mock
```
Note that the new grandR object now only has 6 columns. The `columns` parameter to subset must be a logical vector, and you can use the names of the column metadata table (see below) as variables. 

A closely related function is `split`, which returns a list of several grandR objects, each composed of samples having the same `Condition`.

```{r}
split.list <- split(sars)
split.list
Columns(split.list$Mock)
Columns(split.list$SARS)
```
In inverse of `split` is `join`:

```{r}
sars.mock <- merge(split.list$SARS,split.list$Mock)
Columns(sars.mock)
```
Note that we merged such that now we have first the SARS samples and then the Mock samples. We can reorder by

```{r}
mock.sars <- reorder(sars.mock,order = c(7:12,1:6))
Columns(mock.sars)
```

## Gene metadata

The metadata for genes can be retrieved using the `GeneInfo` function:

```{r}
head(GeneInfo(sars), 10)
```

Each gene has associated gene ids and symbols. Genes can be found by the `Genes` function:

```{r}
head(Genes(sars), n=20)                          # retrieve the first 20 genes
head(Genes(sars,use.symbols = FALSE), n=20)      # the first 20 genes, but now use the ids
Genes(sars,genes = c("MYC","ORF1ab"),use.symbols = FALSE)    # convert to ids
Genes(sars,genes = "YC", regex = TRUE)           # retrieve all genes matching to the regular expression YC
```

From the metadata, gene ids and symbols as well as the transcript length are part of the GRAND-SLAM output. The type is inferred from the gene ids using the `GeneType()` function. By default, this will recognize mitochondrial genes (MT prefix of the gene symbol), ERCC spike-ins, and Ensembl gene identifiers (which it will call "cellular"). Here, we also have the viral genes, that are not recognized:

```{r}
table(GeneInfo(sars,"Type"))
```
If you want to define your own types, you can do this easily be specifying the `classify.genes` parameter when read in your data:

```{r}
viral.genes <- c('ORF3a','E','M','ORF6','ORF7a','ORF7b','ORF8','N','ORF10','ORF1ab','S')
sars <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz",
                  design=c(Design$Condition,Design$dur.4sU,Design$Replicate),
                  classify.genes = GeneType(viral=function(gene.info) gene.info$Symbol %in% viral.genes))
table(GeneInfo(sars,"Type"))
```

Note that each parameter to `GeneType` must be named (`viral`) and must be a function that takes the gene metadata table and returns a logical vector. Here, it might have been easier to rename "Unknown" to viral, which can be accomplished by:

```{r}
sars <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz",
                  design=c(Design$Condition,Design$dur.4sU,Design$Replicate),
                  classify.genes = GeneType(name.unknown = "viral"))
table(GeneInfo(sars,"Type"))
```

Additional gene metadata can be set like this:
```{r}
GeneInfo(sars,"length.category") <- cut(GeneInfo(sars,"Length"),breaks=c(0,2000,5000,Inf),labels = c("Short","Medium","Long"))
table(GeneInfo(sars,"length.category"))
```



## Column (i.e. samples or cells) metadata

The metadata for samples/cells is a table that describes the experimental design we specified
in grandR. It can be accessed via `Coldata(sars)`. Note that we call samples or cells (depending on your experiment)
jointly the "columns" of our experiment. We can also see that the duration of 4sU 
has been interpreted and converted to a numeric value (compare "duration.4sU" with "duration.4sU.original"). 

```{r}
Coldata(sars)
```

Additional metadata can be easily added. At 3h post infection, 4sU was added to the cells for 1,2,3 or 4h. The two no4sU samples are also 3h post infection. The infection time point can be added to this table via:
```{r}
Coldata(sars,"hpi")<-paste0(Coldata(sars,"duration.4sU")+3,"hpi")
Coldata(sars)
```

There are also some grandR functions, that add metadata, such as `ComputeExpressionPercentage`:
```{r}
sars <- ComputeExpressionPercentage(sars,name = "viral_percentage",genes = GeneInfo(sars,"Type")=="viral")
ggplot(Coldata(sars),aes(Name,viral_percentage))+geom_bar(stat="identity")+RotatateAxisLabels()+xlab(NULL)
```
Note that the 4sU-naive sample shows more viral gene expression, suggesting that 4sU had an effect on viral gene expression.

For Coldata, the `Condition` column has a special meaning. It is used by many functions as a default, e.g. to plot colors in the PCA or to model kinetics per conditions. It can be accessed by it's own function:

```{r}
Condition(sars)
```

and it can be set either directly:

```{r}
Coldata(sars,"saved")<-Condition(sars)                  # save it for later use!
Condition(sars)<-rep(c("control","infected"),each=6)    # set new conditions directly
Coldata(sars)
```
or from one or several columns of the metadata (here this this not really reasonable, but there are situations where combining more than one metadata column makes sense):

```{r}
Condition(sars)<-c("saved","Replicate")   # set it by combining to other columns from the Coldata
Condition(sars)
Condition(sars)<-"saved"                  # set it to one other column from the Coldata
Condition(sars)
```






