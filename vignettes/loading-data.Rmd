---
title: "Loading data"
author: "Lygeri Sakellaridi"
date: "3/26/2022"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Loading data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
GRAND-R is an R package for the analysis of RNA-seq experiments that utilize
metabolic labeling, such as SLAM-seq experiments [[1]] (https://doi.org/10.1038/nmeth.4435). In such experiments, cells are subjected to metabolic labeling with nucleoside analogs such as 4SU. After sequencing, reads where 4SU was successfully incorporated have cytosine instead of thymine. Thus, newly transcribed RNA (i.e. RNA transcribed after the start of labeling) can be distinguished from pre-existing RNA on the basis of observed T to C conversions on mapped reads. 

GRAND-R utilizes the GRAND-SLAM statistical
framework [[2]](https://doi.org/10.1093/bioinformatics/bty256) to estimate parameters such as new-to-total (NTR) RNA ratios and half-lives, and quantify the uncertainty associated with the estimates.

# Reading in the data

Throughout this vignette, we will be using the processed SLAM-seq data set
from Finkel et al. 2021 [[3]](https://www.nature.com/articles/s41586-021-03610-3). The data set contains time series samples from the human epithelial cell line (Calu3 cells); half of the samples were infected with SARS-CoV-2 for different periods of time. The input is a tsv file where rows are genes and columns are read counts for all different samples. The data set is available on zenodo
("https://zenodo.org/record/5834034/files/sars.tsv.gz")

The data set is read with the aptly named readGRAND command:

```{r}
suppressPackageStartupMessages({library(grandR)})
sars <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz",
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
```
The design vector describes the experimental design. This assumes that sample
names are composed of three parts separated by dots. Each part in the sample
name represents an aspect of the design. For example, the sample named Mock.2h.A is a sample from the mock condition (i.e. not infected by SARS-CoV-2), subjected to metabolic labeling for 2 hours, and is the first replicate (i.e. replicate "A"). This sample name is consistent with the design vector used above. It is possible to specify other design elements (of course the samples would have to be named accordingly). A list of reasonable options is predefined in the list `Design`. Some names have additional semantics. For example, for the name \emph{duration.4sU} the values are interpreted: e.g. 4h is converted into the number 4, 30min into 0.5, and no4sU into 0.

The design vector is mandatory. Attempting to read in the data without it
results in an error:

```{r}
sars <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz")
```

# Exploring the GRAND-R object

The grandr object contains five slots: prefix, gene.info, data, coldata and
metadata.

```{r}
class(sars)
summary(sars)
```

The "prefix" slot describes the source of the data set:

```{r}
sars$prefix
```

The "gene.info" slot contains, intuitively enough, information on the genes.
The type is deduced by GRAND-R based on nomenclature, but can also be assigned
by the user (see "Custom gene annotation").

```{r}
head(GeneInfo(sars), 3)
```

The data slot is a list of data frames. The data frames are named "count",
"ntr", "alpha" and "beta". They contain, respectively, the values for 
read counts, new-to-total (NTR) RNA ratios, and (for our statistically 
inclined users) the alpha and beta parameters of the NTR posterior distribution 
(for more on what this means, see [[2]]). In each data frame, rows 
represent genes and columns represent samples. 

We can retrieve data with the GetData command. It is possible to specify data
from a particular slot and/or gene (for more on this, please refer to the 
"Getting data" vignette). As a brief demonstration, we will extract the first
three rows from the "count" data frame:

```{r}
head(GetData(sars, mode.slot = "count"), 3)
```

If we normalize the sars data set, the data slot will gain an additional data 
frame named "norm" that stores the normalized counts. This will also become the
default slot.

```{r}
DefaultSlot(sars)
sars.normalized <- Normalize(sars)
DefaultSlot(sars.normalized) # norm
head(GetData(sars.normalized, mode.slot = "norm"), 3)
```

The coldata slot is a table that describes the experimental design we specified
in grandR. It can be accessed via Coldata(sars) (see also 
"The data annotation table" below). We can also see that the duration of 4SU 
has been interpreted (compare "duration.4SU" with "duration.4SU.original"). 

```{r}
Coldata(sars)
```

Finally, the metadata slot is a list that contains metadata about the grandr
object. By default, the type of data and the default slot are described:

```{r}
sars$metadata
```
As we also saw above, the default slot is "count" by to begin with, but changes 
to "norm" after we normalize the grandR object:

```{r}
sars.normalized$metadata
```
To add more metadata, we can use regular list methods:

```{r}
sars.add.metadata <- sars
sars.add.metadata$metadata <- append(sars.add.metadata$metadata, list(third = "some value"))
sars.add.metadata$metadata
```
# The data annotation table

Every GRAND-R object contains an annotation table that describes the experimental
setup. As we saw above, this table can be accessed using Coldata:

```{r}
Coldata(sars)
```

Often, we might want to add more columns to the table. As an example, here we
will add a column that stores information on how many hours have passed since
infection started. In this particular experiment, 4SU was added to the samples
at thee hours post infection. Therefore, to get the hours-post-infection (hpi)
value per sample, we can add 3 to the labeling duration:
```{r}
Coldata(sars, "hpi") <- paste0(Coldata(sars)$duration.4sU+3,"hpi")
Coldata(sars)
```

GRAND-R allows users to specify their own semantics. Thus, it is also possible to directly add the hpi information to the design vector when we first read in 
the data:

```{r}
sema <- list(duration.4sU=
      function(s,name) {
         r<-Semantics.time(s,name)
         cbind(r,data.frame(hpi=paste0(r$duration.4sU+3,"h")))
      })
sars.sema <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz",
                   design=function(names)
                   MakeColdata(names,c("Condition",Design$dur.4sU,Design$Replicate),
                   semantics=sema),
                   verbose=FALSE)
Coldata(sars.sema)

```
Additionally, we can rename existing columns. There are two ways to do this.
First, the user can provide a look-up table and define the correspondences
between current names and desired names. For example, the code below renames
"Mock.2h.A" to "mock.2h.A" and "Mock.1h.A" to "mock.1h.A".

```{r}
lookup.table <- c(Mock.2h.A = "mock.2h.A", Mock.1h.A = "mock.1h.A")
sars.renamed.columns <- RenameColumns(sars, map = lookup.table)
sars.renamed.columns2 <- RenameColumns(sars, fun = function(name) 
  {gsub("Mock", "mock", name)})
Coldata(sars.renamed.columns2)
```

Alternatively, the user can provide a function that specifies a renaming scheme.
This is the more convenient way if we want to rename multiple columns in a 
systematic way. For example, the code below decapitalizes the name of every
mock sample.

```{r}
sars.renamed.columns2 <- RenameColumns(sars, fun = function(name) 
  {gsub("Mock", "mock", name)})
Coldata(sars.renamed.columns2)
```

Finally, we can change the order of columns in the data set with SwapColumns.
While we can do the same thing with reorder, SwapColumns is simpler to use
for situations where you just want to swap a pair of columns, as it sidesteps
the need to define the exact order of all samples.

```{r}
sars.swapped <- SwapColumns(sars, "Mock.2h.A", "Mock.2h.B")
colnames(sars.swapped)
```

# Filtering genes

By default, GRAND-R reads every gene that has at least one mapped read. We can 
use the FilterGenes command to only keep genes that have a minimum number of
reads over a minimum number of samples. For example, the following command
retains genes that have at least 100 reads in at least 6 samples:

```{r}
sars <- FilterGenes(sars, minval = 100, mincol = 6) 
```

The parameter minval represents the minimum number of reads, while mincol
is the minimum number of samples. The default thresholds for these
parameters are, respectively, 100 reads and half the number of samples. 
Consequently, the above command is identical to FilterGenes(sars).

Now that we have added hpi information and filtered the genes, let's
visualize the experimental setup with a PCA plot:

```{r, fig.width=7}
PlotPCA(sars,aest=aes(color=hpi,shape=Condition))
```

# Custom gene annotation

By default, readGRAND annotates genes based on their nomenclature: the type of the gene is assigned as "mito" if the gene name starts with "MT-", "ERCC" if it starts with "ERCC", "Cellular" if it starts with "ENS", and "Unknown"
otherwise.

```{r}
levels(sars$gene.info$Type)
```
For some analyses, it might be useful to specify custom gene types. This
can be done using the "classify.genes" parameter (to-do: classify.genes
creates the user-defined gene types but doesn't assign anything to them).

```{r}
# Load gene sets from msigdb []
library(msigdbr)
library(plyr)
gl <- msigdbr(category = "H")
gl <- dlply(gl,.(gs_name),function(s) s$human_gene_symbol)

# Specify gene sets for only interferon alpha, only interferon gamma,
# genes that participate in both.
interferon.alpha <- gl$HALLMARK_INTERFERON_ALPHA_RESPONSE
interferon.gamma <- gl$HALLMARK_INTERFERON_GAMMA_RESPONSE
interferon.both <- intersect(interferon.alpha, interferon.gamma)
interferon.alpha <- setdiff(interferon.alpha, interferon.both)
interferon.gamma <- setdiff(interferon.gamma, interferon.both)

classi <- c(GeneType,
           `interferon-gamma`=function(gene.info) gene.info$Symbol %in%
                   interferon.gamma,
           `interferon-alpha`=function(gene.info) gene.info$Symbol %in%
                   interferon.alpha,
           `interferon-both`=function(gene.info) gene.info$Symbol %in%
                   interferon.both)
sars.custom.gene.anno <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz",
                 design=c("Condition",Design$dur.4sU,Design$Replicate),
                 classify.genes=classi,
                 verbose=FALSE)
table(GeneInfo(sars.custom.gene.anno)$Type)
# The custom gene types are made, but no genes are assigned to them.
# I checked that genes from the custom sets do exist in the sars data set
# in Gene$Symbol. Either I'm doing something wrong, or classify.genes
# does not work as intended.
# Open issue
```

# Object-related operations: subset, reorder, split, merge

GRAND-R provides several convenience functions to manipulate an object. 

In many cases, it might be desirable to isolate a specific subset of the data.
For example, let's say we want to focus on only the mock samples of our sars
data set. To extract our subset of interest, we can use GRAND-R's subset
function and specify the set of columns we want. 

There are three different ways to specify the columns. First, we can provide
a vector that explicitly stores the desired column names:

```{r}
sars.mock <- subset(sars, columns = c("Mock.no4sU.A", "Mock.1h.A", 
                                      "Mock.2h.A", "Mock.2h.B", 
                                      "Mock.3h.A", "Mock.4h.A"))
Coldata(sars.mock)
```
Alternatively, we can use a logical vector whose length equals the totalnumber 
of columns in the object. In that vector, TRUE means "keep the column" and 
FALSE "don't keep the column". For this to work, the order of the logical values 
in the vector must correspond to the order of the columns as they appear in the
data set.

For example, in our sars object, the first six columns correspond to the mock
samples. Thus, to keep them exclusively, we set the first six values of the
vector to TRUE and the rest to FALSE:
```{r}
sars.mock2 <- subset(sars, columns = c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, 
                                      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE))


Coldata(sars.mock2)
```

Finally, we can specify columns to subset based on the column names of the data 
annotation table. Before showing this, it is useful to prevent any potential 
confusion arising from the different sets of columns we just referred to. 

The columns we specify in the parameter vector are taken from the columns of our 
GRAND-R object. In this case, these are the samples.

```{r}
colnames(sars)
```

In the data annotation table, the samples are the rows. The columns are the 
different aspects of experimental design that we specified when originally
reading in the data, or added later. Examples include: condition, replicate,
and information about duration of labeling.

```{r}
all(colnames(sars) == rownames(Coldata(sars))) # TRUE
colnames(Coldata(sars))
```
We can specify columns from our object that we want to subset (i.e. samples)
based on columns from the data annotation table (eg condition). To retrieve all
the mock samples in this way, we can simply set the Condition to "Mock":

```{r}
sars.mock3 <- subset(sars, columns = Condition == "Mock")
Coldata(sars.mock3)
```

As an addendum: the three ways we just described to specify columns were 
demonstrated on the subset function, but also work for any GRAND-R function
that takes "columns" as a parameter.

To-do: subsetting objects with the first method loses the colnames. 
I think the source code attempts to keep them, so I'm flagging this as 
unintended behavior.

```{r}
colnames(sars.mock) # NULL
colnames(sars.mock2) # expected stuff
colnames(sars.mock3) # expected stuff Open issue
```

If we want to change the order columns appear in our object, we can do so
by providing the new order as a numeric vector whose length equals the total
number of columns. For example, the code below switches the second column
with the first and the eigth column with the seventh:

```{r}
rownames(Coldata(sars))
sars.reordered <- reorder(sars, order = c(2, 1, 3, 4, 5, 6, 8, 7, 9, 10, 11, 12))
rownames(Coldata(sars.reordered))
```

It is also possible to split a GRAND-R object into multiple objects based on
a column of the annotation table. This is different from subsetting in that the
output is a list that stores all objects created from the splitting. For example,
if we split based on condition, we get a list containing two grandR objects:
one with the mock samples and one with the SARS-CoV-2 infected samples. 

```{r}
sars.split <- split(sars, column.name = "Condition")
class(sars.split) # list
names(sars.split) # Mock SARS
class(sars.split[[1]]) # grandR
```
After splitting, the original object is retained:

```{r}
sars
```

Merging grandR objects (to-do):

```{r}
#sars.merged <- merge(sars.split$Mock, sars.split$SARS)
#sars.merged <- merge(list = sars.split)
#Error in as.data.frame(x) : argument "x" is missing, with no default
# Open issue
```



