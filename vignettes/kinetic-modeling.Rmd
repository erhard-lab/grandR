---
title: "Kinetic modeling"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Kinetic modeling}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

One of the main applications of metabolic RNA labeling is to model the kinetics of RNA expression levels [[1]](https://doi.org/10.1093/bioinformatics/bty256)[[2]](https://doi.org/10.1016/j.molcel.2021.06.016). The most natural and widely used model is to describe the change of RNA levels $a(t)$ at time $t$ is via first order reactions by the differential equation:

$$
\frac{da(t)}{dt}=\sigma - \delta \cdot a(t)
$$
Here $\sigma$ is the net synthesis rate of RNA and $\delta$ is the degradation rate. This differential equation can be solved analytically (see e.g. [[1]](https://doi.org/10.1093/bioinformatics/bty256)). Based on this, there are two ways implemented in grandR to estimate both $\sigma$ and $\delta$ by either using non-linear regression on the estimated new and old RNA levels [[2]](https://doi.org/10.1016/j.molcel.2021.06.016) or by a maximum likelihood approach using the posterior distribution of the (new to total RNA ratio) NTR values transformed to degradation rates [[1]](https://doi.org/10.1093/bioinformatics/bty256). Both approaches make use of multiple time points (labeling durations) and are able to estimate both $\sigma$ and $\delta$. The maximum likelihood approach can only be applied under steady state assumptions, whereas the regression approach strictly depends on accurate normalization across individal samples.

To perform an analysis of the RNA dynamics for data from [Finkel et al, Nature 2021](https://www.nature.com/articles/s41586-021-03610-3), we first load the grandR package and the read the GRAND-SLAM output table directly from zenodo:

```{r}
suppressPackageStartupMessages({library(grandR)})
sars <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz",
                  design=c("Condition",Design$dur.4sU,Design$Replicate))
```

Here it is important to specify the design vector. If we omit this parameter, we get the following error message:

```{r error=TRUE}
d <- ReadGRAND("https://zenodo.org/record/5834034/files/sars.tsv.gz")
```

The most convenient way of getting sample annotation data in grandR is by making sure that the sample names follow a particular naming scheme: The names have to contain dots (.) to separate the fields for the column annotation table. E.g. the name \emph{Mock.no4sU.A} will be split into the fields \emph{Mock}, \emph{no4sU} and  \emph{A}. For such names, a design vector of length 3 has to be given to describe the meaning of each field. A reasonable design vector for the example would be `c("Cell","Time","Replicate")`. Some names are predefined in the list `Design` (as used above). The names given in the design vector might even have additional semantics: E.g. for the name `Design$dur.4sU` the values are interpreted (e.g. 4h is converted into the number 4, or 30min into 0.5, or no4sU into 0). Semantics can be user-defined (see the help page for `MakeColdata`). The sample annotation data can be accessed using:

```{r}
ColData(sars)
```
Note that the labeling duration has indeed been interpreted, and the original values are also still available. This table describes the experimental setup: At 3h post infection, 4sU was added to the cells for 1,2,3 or 4h. The two no4sU samples are also 3h post infection. The infection time point can be added to this table via:

```{r}
ColData(sars,"hpi")<-paste0(ColData(sars)$duration.4sU+3,"hpi")
ColData(sars)
```

By default GRAND-SLAM will output all genes (with at least one mapped read), and `ReadGRAND` will read all these genes from the output:

```{r}
sars
```
Thus, we filter to only include genes that have at least 100 reads in at least 6 samples:
```{r}
sars <- FilterGenes(sars,minval = 100, mincol = 6) # as 100 reads and half of the sample is the default, this is identical to sars <- FilterGenes(sars)
sars
```
Note that the actual data is available in so-called 'slots'. `ReadGRAND` adds the read counts, new to total RNA ratios (NTRs) and information on the NTR posterior distribution (alpha,beta).

As a quick quality check, we can inspect a principal component analysis of all samples involved:
```{r,fig.width=7}
PlotPCA(sars)
```
Note that the samples are colored according to the \emph{Condition} annotation. \emph{Condition} has a special meaning in grandR, not only for `PlotPCA`, but also for other analyses (see below). The \emph{Condition} can be set conveniently using the `Condition` functions. For `PlotPCA`, the visual attributes can be adapted via a parameter:
```{r,fig.width=7}
PlotPCA(sars,aest=aes(color=hpi,shape=Condition))
```
There are no obvious problems with the samples, even though the virus infected 3hpi sample is the top-most whereas the other virus infected samples are ordered along infection time from bottom to top.

As pointed out above, for the regression approach it is important to normalize the data:
```{r}
sars<-Normalize(sars)
sars
```
Calling `Normalize` will add an additional slot which is set to be the default slot.

Before we estimate kinetic parameters globally, we inspect an example:
```{r,fig.height=3.5,fig.width=5}
PlotGeneKinetics(sars,"SRSF6")
```

The curves represent the fitted model for this gene. As pointed out above, there are two ways to estimate the RNA kinetics in grandR. The default is the regression approach. The maximum likelihood approach can be used by supplying the `ntr.fit` parameter. It is also possible to exclude samples from the fit, and to drop the assumption of steady state for the virus infected samples:
```{r,fig.height=4.5,fig.width=7}
(PlotGeneKinetics(sars,"SRSF6",bare.plot=T) |
   PlotGeneKinetics(sars,"SRSF6",ntr.fit = T,bare.plot=T))  /
  (PlotGeneKinetics(sars,"SRSF6",use.old=ColData(sars)$Name!="SARS.no4sU.A",bare.plot=T) |
     PlotGeneKinetics(sars,"SRSF6",steady.state=list(Mock=TRUE,SARS=FALSE),bare.plot=T))
```


```{r}
SetParallel()
sars<-FitKinetics(sars,name = "kinetics",steady.state=list(Mock=TRUE,SARS=FALSE))
PlotScatter(sars,type="kinetics","Mock.Half-life","SARS.Half-life",log=T)+geom_abline()
```



```{r}
SetParallel()
sars<-NormalizeKinetic(sars,steady.state = c(Mock=T,SARS=F),set.to.default = FALSE)
sars<-FitKinetics(sars,name="norm_kinetics",slot="norm",time="norm_time",steady.state = c(Mock=T,SARS=F))
sars<-FitKinetics(sars,name="ntr_kinetics",type="ntr")
sars<-FitKinetics(sars,name="normntr_kinetics",type="ntr",time="norm_time")
sars<-FitKinetics(sars,name="lm_kinetics",type="lm")

df<-cbind(GetTable(sars,c("kinetics"),columns="Mock.rmse"),GetTable(sars,c("norm_kinetics"),columns="Mock.rmse"))
PlotScatter(df,xcol=1,ycol=2,log=T)+geom_abline()
```

```{r}
df<-cbind(
  GetTable(sars,c("kinetics"),columns="Mock.Half-life"),
  GetTable(sars,c("norm_kinetics"),columns="Mock.Half-life"),
  GetTable(sars,c("ntr_kinetics"),columns="Mock.Half-life"),
  GetTable(sars,c("normntr_kinetics"),columns="Mock.Half-life"),
  GetTable(sars,c("lm_kinetics"),columns="Mock.Half-life")
  )
PlotScatter(df,xcol=1,ycol=5,log=T)+geom_abline()
(PlotScatter(df,xcol=1,ycol=2,log=T)+geom_abline()|
PlotScatter(df,xcol=3,ycol=2,log=T)+geom_abline())/
(PlotScatter(df,xcol=1,ycol=3,log=T)+geom_abline()|
   PlotScatter(df,xcol=2,ycol=4,log=T)+geom_abline())
```
